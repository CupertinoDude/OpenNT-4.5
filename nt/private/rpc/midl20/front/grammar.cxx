/*
 * Created by CSD YACC (IBM PC) from "grammar.y" */


/****************************************************************************
 ***            local defines
 ***************************************************************************/

#define pascal
#define FARDATA
#define NEARDATA
#define FARCODE
#define NEARCODE
#define NEARSWAP
#define YYFARDATA

#define PASCAL pascal
#define CDECL
#define VOID void
#define CONST const
#define GLOBAL

#define YYSTYPE         lextype_t
#define YYNEAR          NEARCODE
#define YYPASCAL        PASCAL
#define YYPRINT         printf
#define YYSTATIC        static
#define YYCONST         static const
#define YYLEX           yylex
#define YYPARSER        yyparse

#ifdef gajdebug3
#define YYDEBUG
#endif

#define IS_CUR_INTERFACE_LOCAL()  (                                                                     \
        (BOOL) (pInterfaceInfoDict->IsInterfaceLocal()) )

/****************************************************************************
 ***            include files
 ***************************************************************************/

#include "nulldefs.h"


extern "C"      {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
int yyparse();
}

#include "allnodes.hxx"
#include "lexutils.hxx"
#include "gramutil.hxx"
#include "idict.hxx"
#include "filehndl.hxx"
#include "cmdana.hxx"
#include "control.hxx"
#include "tlgen.hxx"

extern "C" {
#include "lex.h"
extern char * KeywordToString( token_t );
}
/***************************************************************************
 *                      local data
 **************************************************************************/

BOOL fBaseImported      = FALSE;
BOOL fOdlBaseImported   = FALSE;
BOOL fLibrary           = FALSE;

/***************************************************************************
 *                      external data
 **************************************************************************/

extern CMD_ARG *            pCommand;
extern node_error *         pErrorTypeNode;
extern node_e_attr *        pErrorAttrNode;
extern SymTable *           pBaseSymTbl;
extern SymTable *           pCurSymTbl;
extern nsa *                pSymTblMgr;
extern short                ImportLevel;
extern BOOL                 fTypeGraphInited;
extern BOOL                 fPragmaImportOn;
extern CCONTROL *           pCompiler;
extern node_source *        pSourceNode;
extern NFA_INFO *           pImportCntrl;
extern PASS_1 *             pPass1;
extern IINFODICT *          pInterfaceInfoDict;
extern unsigned short       LexContext;
extern BOOL                 fRedundantImport;
extern node_skl *           pBaseImplicitHandle;
extern unsigned short       CurrentZp;
extern node_pragma_pack *   pPackStack;

/***************************************************************************
 *                      external functions
 **************************************************************************/

extern void         yyunlex( token_t );
extern BOOL         IsTempName( char * );
extern char *       GenTempName();
extern char *       GenIntfName();
extern char *       GenCompName();
extern void         CopyNode( node_skl *, node_skl * );
extern STATUS_T     GetBaseTypeNode( node_skl **, short, short, short);
extern ATTRLIST     GenerateFieldAttribute( ATTR_T, expr_list *);
extern node_skl *   SearchTag( char *, NAME_T );
extern void         SyntaxError( STATUS_T, short );
extern int          PossibleMissingToken( short, short );
extern char *       MakeNewStringWithProperQuoting( char * );
extern void         CheckGlobalNamesClash( SymKey );
extern void         CheckSpecialForwardTypedef( node_skl *, node_skl *, type_node_list *);
extern void         PushZpStack( node_pragma_pack * & PackStack,
                                unsigned short & CurrentZp );
extern void         PopZpStack( node_pragma_pack * & PackStack,
                                unsigned short & CurrentZp );


/***************************************************************************
 *                      local data
 **************************************************************************/


/***************************************************************************
 *                      local defines
 **************************************************************************/
#define YY_CATCH(x)
#define DEFINE_STRING "#define"
#define LEN_DEFINE (7)

# define KWINTERFACE 257
# define KWCLASS 258
# define KWEXESERVER 259
# define KWDLLSERVER 260
# define KWIMPORT 261
# define KWIMPORTIDLBASE 262
# define KWIMPORTODLBASE 263
# define KWCPPQUOTE 264
# define KWCPRAGMA 265
# define KWCPRAGMAPACK 266
# define KWMPRAGMAIMPORT 267
# define KWMPRAGMAECHO 268
# define KWMPRAGMAIMPORTCLNTAUX 269
# define KWMPRAGMAIMPORTSRVRAUX 270
# define TYPENAME 271
# define LIBNAME 272
# define KWVOID 273
# define KWUNSIGNED 274
# define KWSIGNED 275
# define KWFLOAT 276
# define KWDOUBLE 277
# define KWINT 278
# define KWBYTE 279
# define KWCHAR 280
# define KWSMALL 281
# define KWLONG 282
# define KWSHORT 283
# define KWHYPER 284
# define KWINT64 285
# define KWSTRUCT 286
# define KWUNION 287
# define KWENUM 288
# define KWSHORTENUM 289
# define KWLONGENUM 290
# define KWCONST 291
# define KWVOLATILE 292
# define KW_C_INLINE 293
# define KWTYPEDEF 294
# define KWEXTERN 295
# define KWSTATIC 296
# define KWAUTO 297
# define KWREGISTER 298
# define KWERRORSTATUST 299
# define KWBOOLEAN 300
# define KWISOLATIN1 301
# define KWPRIVATECHAR8 302
# define KWISOMULTILINGUAL 303
# define KWPRIVATECHAR16 304
# define KWISOUCS 305
# define KWPIPE 306
# define KWSWITCH 307
# define KWCASE 308
# define KWDEFAULT 309
# define KWUUID 310
# define KWVERSION 311
# define KWOPAQUE 312
# define KWSTRING 313
# define KWBSTRING 314
# define KWIN 315
# define KWOUT 316
# define KWIIDIS 317
# define KWFIRSTIS 318
# define KWLASTIS 319
# define KWMAXIS 320
# define KWMINIS 321
# define KWLENGTHIS 322
# define KWSIZEIS 323
# define KWID 324
# define KWHC 325
# define KWHSC 326
# define KWLCID 327
# define KWDLLNAME 328
# define KWHELPSTR 329
# define KWHELPFILE 330
# define KWENTRY 331
# define KWPROPGET 332
# define KWPROPPUT 333
# define KWPROPPUTREF 334
# define KWOPTIONAL 335
# define KWVARARG 336
# define KWAPPOBJECT 337
# define KWRESTRICTED 338
# define KWPUBLIC 339
# define KWREADONLY 340
# define KWODL 341
# define KWSOURCE 342
# define KWBINDABLE 343
# define KWREQUESTEDIT 344
# define KWDISPLAYBIND 345
# define KWDEFAULTBIND 346
# define KWLICENSED 347
# define KWPREDECLID 348
# define KWHIDDEN 349
# define KWRETVAL 350
# define KWCONTROL 351
# define KWDUAL 352
# define KWNONEXTENSIBLE 353
# define KWNONCREATABLE 354
# define KWOLEAUTOMATION 355
# define KWLIBRARY 356
# define KWMODULE 357
# define KWDISPINTERFACE 358
# define KWCOCLASS 359
# define KWMETHODS 360
# define KWPROPERTIES 361
# define KWIMPORTLIB 362
# define KWFUNCDESCATTR 363
# define KWIDLDESCATTR 364
# define KWTYPEDESCATTR 365
# define KWVARDESCATTR 366
# define KWSAFEARRAY 367
# define KWAGGREGATABLE 368
# define KWUIDEFAULT 369
# define KWNONBROWSABLE 370
# define KWDEFAULTCOLLELEM 371
# define KWDEFAULTVALUE 372
# define KWCUSTOM 373
# define KWDEFAULTVTABLE 374
# define KWIMMEDIATEBIND 375
# define KWUSESGETLASTERROR 376
# define KWREPLACEABLE 377
# define KWHANDLET 378
# define KWHANDLE 379
# define KWCONTEXTHANDLE 380
# define KWMSUNION 381
# define KWENDPOINT 382
# define KWDEFAULTPOINTER 383
# define KWLOCAL 384
# define KWSWITCHTYPE 385
# define KWSWITCHIS 386
# define KWTRANSMITAS 387
# define KWWIREMARSHAL 388
# define KWIGNORE 389
# define KWREF 390
# define KWUNIQUE 391
# define KWPTR 392
# define KWV1ARRAY 393
# define KWV1STRUCT 394
# define KWV1ENUM 395
# define KWV1STRING 396
# define KWIDEMPOTENT 397
# define KWBROADCAST 398
# define KWMAYBE 399
# define KWASYNC 400
# define KWINPUTSYNC 401
# define KWCALLBACK 402
# define KWALIGN 403
# define KWUNALIGNED 404
# define KWOPTIMIZE 405
# define STRING 406
# define WIDECHARACTERSTRING 407
# define KWTOKENNULL 408
# define NUMERICCONSTANT 409
# define NUMERICUCONSTANT 410
# define NUMERICLONGCONSTANT 411
# define NUMERICULONGCONSTANT 412
# define HEXCONSTANT 413
# define HEXUCONSTANT 414
# define HEXLONGCONSTANT 415
# define HEXULONGCONSTANT 416
# define OCTALCONSTANT 417
# define OCTALUCONSTANT 418
# define OCTALLONGCONSTANT 419
# define OCTALULONGCONSTANT 420
# define CHARACTERCONSTANT 421
# define WIDECHARACTERCONSTANT 422
# define IDENTIFIER 423
# define KWSIZEOF 424
# define TOKENTRUE 425
# define TOKENFALSE 426
# define MSCDECLSPEC 427
# define MSCDLLIMPORT 428
# define MSCDLLEXPORT 429
# define MSCEXPORT 430
# define MSCFORTRAN 431
# define MSCCDECL 432
# define MSCSTDCALL 433
# define MSCLOADDS 434
# define MSCSAVEREGS 435
# define MSCFASTCALL 436
# define MSCSEGMENT 437
# define MSCINTERRUPT 438
# define MSCSELF 439
# define MSCNEAR 440
# define MSCFAR 441
# define MSCUNALIGNED 442
# define MSCHUGE 443
# define MSCPASCAL 444
# define MSCEMIT 445
# define MSCASM 446
# define KWNOCODE 447
# define POINTSTO 448
# define INCOP 449
# define DECOP 450
# define MULASSIGN 451
# define DIVASSIGN 452
# define MODASSIGN 453
# define ADDASSIGN 454
# define SUBASSIGN 455
# define LEFTASSIGN 456
# define RIGHTASSIGN 457
# define ANDASSIGN 458
# define XORASSIGN 459
# define ORASSIGN 460
# define DOTDOT 461
# define LTEQ 462
# define GTEQ 463
# define NOTEQ 464
# define LSHIFT 465
# define RSHIFT 466
# define ANDAND 467
# define EQUALS 468
# define OROR 469
# define NOTOKEN 470
# define GARBAGETOKEN 471
# define KWOBJECT 472
# define KWSHAPE 473
# define KWBYTECOUNT 474
# define KWIMPLICITHANDLE 475
# define KWAUTOHANDLE 476
# define KWEXPLICITHANDLE 477
# define KWREPRESENTAS 478
# define KWCALLAS 479
# define KWCODE 480
# define KWINLINE 481
# define KWOUTOFLINE 482
# define KWINTERPRET 483
# define KWNOINTERPRET 484
# define KWCOMMSTATUS 485
# define KWFAULTSTATUS 486
# define KWHEAP 487
# define KWINCLUDE 488
# define KWPOINTERSIZE 489
# define KWOFFLINE 490
# define KWALLOCATE 491
# define KWENABLEALLOCATE 492
# define KWMANUAL 493
# define KWNOTIFY 494
# define KWNOTIFYFLAG 495
# define KWUSERMARSHAL 496
# define KWENCODE 497
# define KWDECODE 498
# define KWBITSET 499
# define UUIDTOKEN 500
# define VERSIONTOKEN 501
# define EOI 502
# define LASTTOKEN 503
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
extern YYSTYPE yylval;  /*CSD & DECUS LEX */
YYSTYPE yyval;          /*CSD & DECUS LEX */
# define YYERRCODE 256



/***************************************************************************
 *              utility routines
 **************************************************************************/
YYSTATIC VOID FARCODE PASCAL
yyerror(char *szError)
        {
        // this routine should really never be called now, since I
        // modified yypars.c to report errors thru the ParseError
        // mechanism

                fprintf(stderr, szError);
        }
void
NTDBG( char * p )
        {
        printf("VC_DBG: %s\n", p );
        }



short YYCONST yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 6,
	125, 73,
	-2, 289,
-1, 37,
	125, 73,
	-2, 289,
-1, 40,
	125, 72,
	-2, 289,
-1, 57,
	59, 218,
	-2, 236,
-1, 111,
	125, 28,
	-2, 289,
-1, 261,
	59, 231,
	41, 231,
	58, 231,
	44, 231,
	61, 231,
	-2, 236,
-1, 287,
	41, 229,
	-2, 236,
-1, 302,
	123, 172,
	-2, 171,
-1, 304,
	307, 172,
	123, 172,
	-2, 180,
-1, 306,
	123, 172,
	-2, 134,
-1, 308,
	125, 27,
	-2, 289,
-1, 383,
	40, 167,
	-2, 230,
-1, 412,
	360, 39,
	-2, 289,
-1, 555,
	40, 167,
	-2, 232,
-1, 575,
	360, 38,
	-2, 289,
-1, 618,
	41, 229,
	-2, 236,
-1, 701,
	125, 182,
	-2, 289,
-1, 710,
	125, 439,
	-2, 289,
-1, 714,
	59, 216,
	44, 216,
	-2, 236,
-1, 748,
	41, 229,
	-2, 236,
-1, 787,
	125, 43,
	-2, 289,
-1, 806,
	41, 274,
	44, 274,
	-2, 236,
-1, 820,
	125, 42,
	-2, 289,
-1, 823,
	59, 216,
	44, 216,
	-2, 236,
	};
# define YYNPROD 530
# define YYLAST 1955
short YYCONST yyact[]={

 505, 577, 396,  22,   7, 789,   7, 465,  42, 464,
 704, 764, 620, 780, 542,  57, 778, 569, 266, 134,
 138, 506, 661, 136, 471, 702,  61, 139, 395, 133,
 135, 709, 137, 125, 688, 539, 369, 619, 457,  42,
 431,  67,  42, 461, 463, 459,  84, 456, 423, 462,
 460, 458, 547, 386,  85, 436,  43, 533, 255,  44,
 259,  61, 455, 590, 530, 451, 113, 114,  33, 588,
 589, 110, 109, 523, 599, 606,  67, 286,  90, 605,
  33, 611, 612, 691, 287, 601, 537,  61, 557, 558,
 326, 607,  67, 608, 783, 767, 747, 746, 711, 653,
 566, 561,  67,  67, 582,  33, 449, 328,  91,  92,
 326, 394, 420,   7, 432,  42, 323, 314, 585, 584,
 774, 775, 141, 144, 157, 149, 150, 185, 186, 166,
 159, 160, 163, 162, 161, 164, 167, 168, 169, 170,
 175, 176, 177, 178, 194, 195, 196, 197, 198, 212,
 199, 213, 200, 214, 201, 206, 207, 208, 209, 215,
 210, 193, 211, 216, 217, 218, 220, 219, 516,  91,
  92, 317,  50, 296, 300, 171, 172, 173, 174, 515,
 221, 222, 223, 224, 179, 180, 202, 203, 205, 204,
 514, 148, 151, 156, 140, 145, 142, 152, 165, 153,
 154, 184, 181, 182, 183, 229, 231, 158, 230, 188,
 189, 190, 191, 192, 187, 227, 228, 675, 676, 677,
 678, 679, 680, 681, 682, 683, 684, 118, 622, 331,
 330, 329, 321, 310, 624, 383,  32,  31,  16,  17,
  18,  21,  25,  26,  27,  28,  29,  30,  32,  31,
  16,  17,  18,  21,  25,  26,  27,  28,  29,  30,
 124, 517, 712, 132, 518,  63,   3, 443, 519, 117,
 689, 378, 520,  51,  61,  62, 525,  50, 290, 621,
 781, 782, 294, 385, 143, 556, 258, 225, 226,  67,
 398, 155, 400, 263, 388, 373, 291, 184, 181, 182,
 183,   5, 289,  95, 110, 109,  35, 290,  91,  92,
   7, 385, 260, 384,  42, 421, 410, 578,  75,  74,
  76, 526,   7, 809, 697, 450, 802, 814, 108, 298,
 107, 105, 106,  33, 390, 110, 109, 784, 770,  12,
 411,  33, 108, 298, 107, 105, 106, 405, 408, 534,
 232,  12, 507, 508, 509, 510, 511, 512, 513,  33,
  33, 435, 390, 521, 453, 453, 453, 453, 453, 453,
 453, 453, 442, 446, 446, 768, 300,  75,  74,  76,
 540, 316, 364, 655, 259, 437, 602,  33, 549, 564,
 546, 553,  33, 438, 292, 543, 404, 399, 297, 397,
 371, 527, 375, 603, 545, 696, 570, 299, 108, 298,
 107, 105, 106, 309, 503, 504, 322, 296, 296, 296,
 583, 409, 243, 576, 741, 388, 313, 248, 241, 845,
 808, 239, 693, 690, 755,  33, 706, 548, 390, 534,
 333, 122, 571, 786, 382,  93, 761, 528, 573, 838,
 421, 692, 562, 563, 282, 580, 753, 281, 272, 273,
 274, 275, 276, 277, 278, 279, 280, 268, 267, 270,
 269, 271, 283, 796, 546, 831, 403, 627, 625, 417,
 600, 374, 618, 754, 326,  61, 244, 613, 545, 332,
 752,  34, 242, 609, 610, 240,  33, 370, 327, 715,
  67,  32,  31,  16,  17,  18,  21,  25,  26,  27,
  28,  29,  30, 282,  91,  92, 281, 272, 273, 274,
 275, 276, 277, 278, 279, 280, 268, 267, 270, 269,
 271, 283, 579,  21,  25,  26,  27,  28,  29,  30,
 295, 572,  91,  92, 301, 303, 305, 324, 837, 773,
 247, 245, 546, 823, 663, 667, 392, 543, 665, 673,
 671, 413, 668, 319, 662, 664, 545, 666, 822, 366,
 238, 236, 380, 699, 391, 670, 781, 782, 318, 791,
  33,  33, 824, 816, 741, 787, 713, 416, 658, 414,
 659, 657, 651, 714, 656, 842,  61, 429, 793, 412,
 292, 442, 293, 805,  12, 445, 445, 546, 447, 548,
 406,  67, 758, 749, 437, 444, 444, 707,  60,  59,
 453, 545, 438, 708, 739, 717, 710, 555, 720, 546,
 546, 716, 428, 427, 546, 745, 623, 724, 496, 830,
 497, 727, 748, 545, 545,  61, 296, 740, 545, 726,
 729, 732, 733, 734, 735, 728, 730, 731, 738, 743,
  67, 736, 737, 725, 723,  33, 387, 424, 541, 498,
 499, 500, 501, 502, 540, 617, 843, 285, 284, 844,
 615, 797, 546, 742, 798, 616, 741, 759, 765, 288,
 381, 319, 751, 766, 387, 632, 545, 631, 598, 630,
 598, 829, 598, 629, 757, 628, 598, 756, 598, 769,
 597, 817, 570, 598, 772, 586, 804, 790, 587, 794,
 760, 792, 750, 722, 721, 719, 718, 771, 785,   9,
 695,  91,  92, 550, 110, 109,  41, 694,  94, 439,
  96, 108, 298, 107, 105, 106, 687, 654, 441, 546,
 800, 652, 650, 649, 795, 648, 647, 646, 645, 644,
 440, 613, 613, 545, 643, 642, 546,  41, 641, 640,
 235, 543, 639, 803, 638, 663, 667, 799, 801, 665,
 545, 806, 815, 668,  61, 662, 664, 818, 666,  42,
 813, 821, 825, 812, 810, 637, 636, 635, 634,  67,
 633, 596, 595, 594, 827, 592, 546, 765, 835, 833,
 591, 828,  75,  74,  76, 826, 581, 832, 559, 836,
 545, 426,  42, 425, 839, 841, 790, 422, 418, 840,
 407, 807, 686, 567, 393,  16,  17,  18,  21,  25,
  26,  27,  28,  29,  30, 846, 669, 141, 144, 157,
 149, 150, 185, 186, 166, 159, 160, 163, 162, 161,
 164, 167, 168, 169, 170, 175, 176, 177, 178, 194,
 195, 196, 197, 198, 212, 199, 213, 200, 214, 201,
 206, 207, 208, 209, 215, 210, 193, 211, 216, 217,
 218, 220, 219, 368, 367, 365, 363, 362, 361, 360,
 171, 172, 173, 174, 359, 221, 222, 223, 224, 179,
 180, 202, 203, 205, 204, 358, 148, 151, 156, 140,
 145, 142, 152, 165, 153, 154, 184, 181, 182, 183,
 229, 231, 158, 230, 188, 189, 190, 191, 192, 187,
 227, 228, 357, 356, 355, 354, 353, 352, 282, 351,
 350, 281, 272, 273, 274, 275, 276, 277, 278, 279,
 280, 268, 267, 270, 269, 271, 283, 349, 348, 347,
 472, 346, 345, 344, 343, 473, 342, 466, 341, 474,
 496, 340, 497,  75,  74,  76, 339, 338, 337, 336,
 335, 334, 472, 130, 129, 128, 127, 473, 126, 466,
 121, 474, 496, 112, 497, 604, 674, 522, 434, 143,
 433, 560, 225, 226, 320, 111, 155, 141, 144, 157,
 149, 150, 185, 186, 166, 159, 160, 163, 162, 161,
 164, 167, 168, 169, 170, 175, 176, 177, 178, 194,
 195, 196, 197, 198, 212, 199, 213, 200, 214, 201,
 206, 207, 208, 209, 215, 210, 193, 211, 216, 217,
 218, 220, 219, 475,   2, 452, 565, 701, 703, 700,
 171, 172, 173, 174,  38, 221, 222, 223, 224, 179,
 180, 202, 203, 205, 204, 475, 148, 151, 156, 140,
 145, 142, 152, 165, 153, 154, 184, 181, 182, 183,
 229, 231, 158, 230, 188, 189, 190, 191, 192, 187,
 227, 228, 233, 147, 468, 377,  88,  87,  64, 282,
 116, 402, 281, 272, 273, 274, 275, 276, 277, 278,
 279, 280, 268, 267, 270, 269, 271, 283, 119, 120,
  91,  92,  80, 110, 109,  77,  79,  94,  82,  96,
 108,  78, 107, 105, 106, 102, 103, 104, 698,  23,
  75,  74,  76, 325,  70,  71,  72,  73,  24,  81,
  97,  98,  99, 100, 101,  69, 264, 575, 470, 143,
 472, 467, 225, 226, 115, 473, 155, 466,   8, 474,
 496, 261, 497, 415, 685,  39, 762, 763, 574, 311,
 819, 256, 237, 531,  47, 401, 777, 123,  91,  92,
  80, 110, 109,  77,  79,  94,  82,  96, 108,  78,
 107, 105, 106, 102, 103, 104, 234, 779,  75,  74,
  76, 776,  70,  71,  72,  73,  68,  81,  97,  98,
  99, 100, 101,  69, 811, 472,  37,  83, 614,  46,
 473,  13, 466, 312, 552, 496, 262, 497, 249, 250,
 251, 252, 253, 254,  20, 820, 788, 454,  48, 308,
 544,  11, 307, 475,   4,   6,  40,  36, 672,  86,
 257, 265,  89, 568,  65, 430, 705, 538, 536,  14,
 315,  58, 379,  49,  19, 834,  10, 419,  45, 529,
  66, 246, 532,  15,  68, 551, 660, 131, 389, 472,
 302, 304, 306, 554, 473,  83, 626, 744, 474, 496,
 146, 497, 524, 448,   1,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0, 475,   0,
   0,   0,   0, 492, 493, 491, 477, 478, 479, 480,
 481, 482, 483, 484, 485, 486, 487, 488, 494, 495,
 476, 469, 489, 490,   0, 492, 493, 491, 477, 478,
 479, 480, 481, 482, 483, 484, 485, 486, 487, 488,
 494, 495, 476, 469, 489, 490,   0,   0,   0,  50,
  54,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 475,  91,  92,  80, 110, 109,  77,  79,
  94,  82,  96, 108,  78, 107, 105, 106, 102, 103,
 104,   0,   0,  75,  74,  76,  56,  70,  71,  72,
  73,   0,  81,  97,  98,  99, 100, 101,  69,   0,
   0,   0,   0,   0,   0,   0, 372,   0,   0,   0,
   0,   0,   0,   0,   0, 376,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,  91,  92,  80, 110, 109,  77,  79,  94,  82,
  96, 108,  78, 107, 105, 106,   0,   0,  55,  53,
  51,  52,   0,   0,   0,   0,   0,   0,   0,  68,
  81,  97,  98,  99, 100, 101,   0,   0,   0,   0,
  83,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 492, 493, 491, 477, 478, 479, 480,
 481, 482, 483, 484, 485, 486, 487, 488, 494, 495,
 476, 469, 489, 490,   0,   0,   0,   0,  83,   0,
   0,   0,   0, 535,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0, 492, 493,
 491, 477, 478, 479, 480, 481, 482, 483, 484, 485,
 486, 487, 488, 494, 495, 476, 469, 489, 490,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 593,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 492, 493, 491, 477, 478, 479, 480, 481,
 482, 483, 484, 485, 486, 487, 488, 494, 495, 476,
 469, 489, 490,  91,  92,  80, 110, 109,  77,  79,
  94,  82,  96, 108,  78, 107, 105, 106, 102, 103,
 104,   0,   0,  75,  74,  76,  56,  70,  71,  72,
  73,   0,  81,  97,  98,  99, 100, 101,  69,  91,
  92,  80, 110, 109,  77,  79,  94,  82,  96, 108,
  78, 107, 105, 106, 102, 103, 104,   0,   0,  75,
  74,  76,   0,  70,  71,  72,  73,   0,  81,  97,
  98,  99, 100, 101,  69,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,  68,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  83,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  68,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  83,  91,  92,  80,
 110, 109,  77,  79,  94,  82,  96, 108,  78, 107,
 105, 106, 102, 103, 104,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,  81,  97,  98,  99,
 100, 101,  69,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,  68,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,  83 };
short YYCONST yypact[]={

-1000,-1000, 242,-1000, -11,-1000, 574,1132,-1000,-1000,
-1000,-1000, 963,-1000,-1000, 344,-179,-179,-179,-1000,
-1000, 960,-1000,-163,-1000,-1000, 958, 956, 955, 954,
 953,-1000,-1000, 707,-1000,-1000, 225, 574,-1000,-1000,
 269,-1000,1432, 512, 372, 369, 363, 492, 304,-1000,
-163,-163,-163,-163,-163,-163, 344,  86,1468,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,1468,1576,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,  25,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-203,-1000, 556,   4,  61, 127,-1000,-1000,-1000,-1000,
-1000,-1000,-163,-163,-163,-1000,-1000,-1000,-1000,-1000,
-1000, 242,-173, 301,  20,-1000, 519,-1000,-1000, 647,
 647,-174, 293,-1000,-1000,-1000,  75,-316,-175,-176,
-177, 396,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
 951, 950,-1000,-1000, 949, 948,-1000,-1000,-1000,-1000,
-1000,-1000, 947, 946, 941, 938,-1000,-1000,-1000, 936,
 934, 933, 932, 931, 929, 928, 927, 910, 909, 907,
 906, 905, 904, 903, 902, 875, 864, 859, 858, 857,
 856,-1000,-1000,-1000,-1000, 855, 855,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000, 854,-1000, 853,-1000,-1000,
-1000,-1000, 438,-1000,-1000,-1000,-1000, 277,-163,-1000,
-1000,-1000,-1000,-1000,-1000,-1000, 358,-163,-1000,-1000,
-1000,-1000,-1000,-1000,-1000, 869, 513, 646,-1000, 383,
 271,  86,  86,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000, 794,-298,-1000,-1000,-1000,  86,-1000,-1000,
-1000, 276,-1000,  19,-1000,-1000,  30,  47,  -4,-1000,
-1000, 274,-1000, 169,-1000, 273,-1000, 222, 242,-1000,
 789, 438, 296,-1000,-1000, 215, 541, 502,-1000,-179,
 -23, 787,  57,-1000, 786, 623,-1000,-1000, 782, 780,
 589, 588,-1000, 707,-292,-1000,-1000, -92, 460,1200,
1200,-317, 959, 959, 959, 959, 959, 959, 959, 959,
 959, 959, 959, 959, 959, 959, 959, 959,-216,-227,
-238,-145, 959,-1000,-1000,-400,-1000,-102,  47,-1000,
-1000,-1000,-1000, 348,-1000,-163,-1000,  27,-1000,-1000,
-1000,  86,1147, 347,-1000, 692,-1000,-1000,-1000,-1000,
1212, 243,-1000,-340,-1000, 777,-1000,-322,-1000,-1000,
-1000, 266,-323, 793, 344, 438,-1000, 482,-1000,-1000,
-1000, 438, 344,-1000,-1000,-1000,-1000,-1000,-1000, 192,
-1000,  37,-1000, 775,-319,-1000,-1000,-287,-288,-1000,
 674,-1000,-1000,-430,-438, 769, 764,-1000,-1000,-1000,
-1000,-163,-1000, 762,-1000,-1000,-1000, 761, 760,-1000,
 669,-1000,-1000,-1000,  11,-382, 262, 309, 967,-389,
  31,-384, 595, 638,-1000,-1000, 937, 188, 959,1276,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000, 664, 662,
 658, 656, 654, 759, 757, 756,-1000, 755, 754, 733,
 731, 728, 727, 724, 723, 718, 717, 716, 715, 714,
 712, 711,-430, 710,-324,-1000,-1000,-1000, 706, 258,
-1000, -85, 348,-1000, 537,-1000,-1000,-1000, 516,-1000,
-1000,-1000,-1000,-1000,1147,-1000,-234, 792,-1000, 705,
 -21,-1000, 340, -10, 339, 347,-1000, 696, 689,-1000,
 280,-1000, 344, 345,-1000,-1000,-1000, 460, 582,-1000,
-325,-1000,-1000,-1000, -98, 344,-1000,1468,-1000,-1000,
 440,-1000, 581,-1000, 685, 684,-1000,-292, 683,-1000,
 682,-1000,-1000,-1000,-1000,-1000,-1000,-1000, 959, 959,
 959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
 959, 959, 959, 959, 959,-1000,-1000,-1000,  86, 642,
-1000, 959, 959,-326,-327,-1000, 937,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000, 569,-1000, 681,-1000, 438,-1000, 431, 397,-1000,
 390,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,  86, 568,-1000, 959,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000, -21, 405,-1000,-1000,-1000,
-1000,-1000, 959,-1000,-1000,-1000,-1000,-328, 250,-1000,
 213, 345,-1000, 490,-1000,-1000,-188, -28,-329, 212,
 344, 382, 527,-1000, 521,-1000, 680,-299,-1000,-1000,
-1000,-1000,-1000,-1000, 540,-382, 262, 309, 967,-389,
  31,  31,-384,-384,-384,-384, 595, 595, 638,-1000,
 678, 959,-1000, 380, 640,-1000,-1000,-1000,  86, 959,
-1000,-1000,-1000,-1000,-1000, 537,-1000, 201,1147,-1000,
-1000,-1000, 675, 559,-1000,1468,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000, 791, 337, 198, -28,-1000, 268,
-1000, 959, 525, 670,-1000,-1000, 959, 344, 509,-1000,
 524, 959,-1000, 959, 959,-1000,-1000,-1000, 959, 660,
 598,-1000,-1000,-1000,-1000,  14,  86, 959, 489,-1000,
-1000,-1000,-1000,-1000,-1000, 391,-1000,-1000,-1000,-1000,
 344,-1000,-1000, 521, 959,-1000,-1000,-1000,-1000,-1000,
-1000, 549,-1000,-1000, 635,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000, 336, 959,-1000,-1000 };
short YYCONST yypgo[]={

   0,1324,1323,1322,1320,  49,  24,  51,1317,1313,
  53,1308,  12,1307,1306,1303,1302,1168,  57,  65,
 325,1301, 275,1300,   9,  54,  64,1299,1298, 112,
1297,1296,  21,   0,1295,1294,1293,1291,  15,   2,
 235,1290,1289,  59,  35,1288,1287,1286,  32,  40,
1285,1284,  17,1283,1282,  45,  38,  37,  30,1281,
  69,1188, 269,1120,  47, 286,1280,1279, 445,  78,
  46,  14,1278, 266,  29,1277,1074, 729,1276,1275,
1274,  56,1272,1271,1269,1268,  62,1267,  10,   5,
1266,   3,1265,1264, 293,1256,1253,1251,1249,1248,
1246,  44,1244,1231,  16,  13,1227,1206,1205,1204,
  27, 263,  22, 301,  20,   1,1203,1202,  31,  34,
  28,1201,1200, 312,1199,1198, 441,  48, 382, 420,
  11,1197,1196,1194,1193,1191,1181, 265,1178,1177,
  23,1176,1163,  50,1159,  43, 303, 267, 618,1158,
1121,  55,1207,1118,1117,1116,  19,1115,  33,  18,
 619,   7,1114,1113,1069,  25,1068,1067,1066,1065,
1064,  36,1015,  52,1014,1011,1010,1008,1007,1006 };
short YYCONST yyr1[]={

   0,   1,  73,  80,  80,  84,  84, 113, 113, 113,
 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
 113,  97,  42, 171, 171,  83,  85,  82,  82,  98,
 124, 124,  96,  96,  43,  41,  41,  41, 125, 125,
 139, 139, 122, 122,  92,  92,  91,  28,  27,  27,
  26,  26, 172, 170,  79,  79, 117, 117,  21,  21,
  81, 109,  31,  30,  30, 158, 158,  29, 144, 144,
  75,  75,  76,  76, 100, 100,  61,  61,  61,  63,
  63, 174,  62, 134, 134,  78,  78,  77,  77,  77,
  77,  35,  35,  35,  35,  35, 142, 127, 127, 129,
  93,  93,  93,  93,  36,  36, 157, 157, 147, 147,
 147,  38,  38,  37,  37,  37,  37, 148, 148, 148,
 148, 160, 160, 160, 160, 160, 160, 160, 160,  23,
 175, 175,  51,  54,  54,  53,  53,  52,  52, 137,
  22,  22,  22,  22,  22,  22,  22,  22,  22,  25,
  25,  70,  70,  70,  70,  68,  68,  68,  68, 146,
 146,  69,  69,  69,  69,  69,  69, 173, 153, 153,
 154, 154, 126, 126, 152, 152, 149, 149,  88, 155,
 155, 155, 164, 167, 167, 165, 165, 165, 165, 166,
  47,  47, 108, 108, 103, 107, 107, 104, 102, 102,
 106, 106, 105, 105, 150, 168,  34,  34, 159, 159,
 159,  90,  90,  89,  89,  89,  89, 121, 121,  66,
  66,  65,  65,  45,  45,  46,  46,  44, 120, 120,
  39,  39,  39, 135, 135, 123, 123,  95,  95,  94,
  94,  94, 141, 141, 141, 141,  59,  59,  59,  59,
  59,  59,  59,  59,  59,  59,  59,  59,  59,  59,
  40,  40,  40,  40,  40,  40,  40, 133, 133, 132,
 132, 131, 131, 130, 130, 119, 119,  10,  11,  11,
  11,  11,   9,  67,  67,  67,  67,  67, 115, 115,
 116, 116,  15,  15,  16,  16,  17,  18,  13,  13,
  14,  14, 111, 111, 111, 111, 111, 111, 111, 112,
 112, 112, 112, 112, 112, 112, 112,  74, 176,  74,
  74,  74, 177,  74,  74,  74,  74,  60,  50,  50,
  49,   4,   4,   3,   3,   3, 156, 156, 156, 156,
 156, 156, 156, 156, 156, 156, 156, 156,   2, 163,
 163, 163, 163, 163, 140, 140, 140, 140, 151, 151,
 151, 151, 151, 151,  58,  58,  58,  58,  58,  58,
  58,  58,  58,  58,  58,  58,  58,  58,  58,  58,
  58,  58,  58,  58,  58,  58,  58,  58, 178,  58,
  20,  20,  19,  19,  48,  48, 114, 114, 114, 114,
 114, 114, 110, 110, 110, 110, 110, 110, 110, 110,
 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
 110, 110, 110, 110, 110, 128, 128,  71,  71, 118,
 118,  72,  72,  57,  57, 169,  33,  12,  12,  32,
  32,  87,  87,  86,  86,  64,  64,  56,  56,   7,
   7,  55,  55,  55, 143, 143, 143, 143, 143, 145,
 145, 145,   5,   5, 101, 101,  24,  24, 161, 161,
 161, 161, 136, 136, 136, 136, 136, 138, 138, 138,
 138, 138, 138, 138, 138, 138, 138, 138, 138, 138,
 138, 138, 138, 138, 138, 138, 138, 138, 162, 162,
 162, 162, 162,   6,   6,  99,  99,  99,   8,   8,
 179, 179, 179, 179, 179, 179, 179, 179, 179, 179 };
short YYCONST yyr2[]={

   0,   2,   2,   2,   1,   2,   1,   4,   3,   3,
   3,   3,   3,   1,   1,   1,   5,   5,   4,   5,
   7,   3,   3,   1,   0,   3,   2,   1,   0,   2,
   2,   1,   2,   1,   2,   6,   2,   0,   1,   0,
   2,   1,   1,   0,   2,   1,   2,   2,   2,   1,
   3,   3,   0,   0,   4,   4,   2,   0,   2,   3,
   2,   2,   5,   2,   1,   1,   3,   3,   1,   1,
   2,   1,   1,   0,   2,   1,   3,   2,   2,   1,
   3,   0,   3,   1,   1,   2,   1,   1,   1,   4,
   1,   1,   3,   4,   5,   7,   1,   2,   0,   1,
   4,   4,   6,   6,   4,   3,   1,   1,   1,   1,
   1,   2,   1,   2,   2,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   4,   2,   5,
   1,   3,   1,   6,   2,   1,   3,   2,   4,   1,
   1,   2,   1,   1,   1,   1,   1,   1,   1,   2,
   1,   2,   1,   2,   1,   1,   1,   2,   2,   1,
   1,   1,   2,   1,   1,   1,   1,   0,   1,   1,
   6,   2,   1,   0,   1,   1,   2,   1,   4,   6,
   2,   7,   1,   2,   1,   2,   2,   1,   1,   6,
   4,   4,   1,   2,   1,   2,   1,   2,   1,   1,
   2,   1,   3,   2,   5,   1,   3,   1,   1,   1,
   1,   1,   3,   1,   2,   3,   0,   1,   0,   1,
   3,   1,   3,   1,   2,   1,   3,   1,   1,   0,
   2,   1,   3,   2,   3,   1,   0,   1,   2,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   4,   4,   2,
   3,   4,   3,   2,   1,   1,   1,   2,   3,   1,
   4,   1,   3,   3,   2,   1,   0,   1,   2,   3,
   3,   3,   3,   1,   1,   1,   1,   1,   1,   0,
   1,   0,   2,   1,   2,   1,   3,   3,   3,   1,
   3,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   4,   0,   5,
   1,   1,   0,   5,   4,   1,   0,   1,   1,   3,
   1,   5,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   4,   4,   4,   4,   1,   1,   1,   1,   4,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   2,   1,   4,   4,   4,   4,   4,   4,
   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
   4,   4,   4,   4,   4,   4,   4,   4,   0,   7,
   3,   1,   1,   0,   2,   2,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   3,   0,   1,   4,   1,
   0,   1,   3,   1,   3,   1,   1,   1,   3,   1,
   5,   1,   3,   1,   3,   1,   3,   1,   3,   1,
   3,   1,   3,   3,   1,   3,   3,   3,   3,   1,
   3,   3,   1,   3,   1,   3,   1,   5,   1,   2,
   5,   2,   1,   4,   4,   3,   3,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   3,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   3,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1 };
short YYCONST yychk[]={

-1000,  -1,-170, -73, -80,-113, -79,-115, -61, -77,
 -31, -83, 362, -97, -42, -15, 261, 262, 263, -35,
 -93, 264, -91,-144, -17, 265, 266, 267, 268, 269,
 270, 260, 259,  91, 502,-113, -75,-100, -76, -61,
 -78, -77,-115, -81, -43, -28, -98,-109, -85, -36,
 257, 358, 359, 357, 258, 356, 294, -38, -37,-160,
-148,-159, -22,-137,-153, -51, -23,-158, 367, 306,
 295, 296, 297, 298, 292, 291, 293, 276, 282, 277,
 273, 300, 279, 378, -70, -25, -67,-154,-155, -54,
 -69, 271, 272, -68, 278,-146, 280, 301, 302, 303,
 304, 305, 286, 287, 288, 284, 285, 283, 281, 275,
 274,-172,  40,-173,-173, -17, -63, -62, 406, -63,
 -63,  40,-126,-152, 423,-158,  40,  40,  40,  40,
  40, -13,-111, -74,-156, -58,-140, -48,-114,-110,
 382, 310, 384, 472, 311, 383,  -4,-163, 379, 313,
 314, 380, 385, 387, 388, 479, 381, 312, 395, 318,
 319, 322, 321, 320, 323, 386, 317, 324, 325, 326,
 327, 363, 364, 365, 366, 328, 329, 330, 331, 372,
 373, 390, 391, 392, 389, 315, 316, 402, 397, 398,
 399, 400, 401, 349, 332, 333, 334, 335, 336, 338,
 340, 342, 374, 375, 377, 376, 343, 344, 345, 346,
 348, 350, 337, 339, 341, 347, 351, 352, 353, 355,
 354, 368, 369, 370, 371, 475, 476, 403, 404, 393,
 396, 394, 125, -76, -61, -77,  59,-117,  58,  59,
 123,  59, 123,  59, 123,  59, -21,  58, 123,-152,
-152,-152,-152,-152,-152,-115,-121, -66, -65, -39,
-123,-135, -95, -94,-141, -59,-159, 441, 440, 443,
 442, 444, 431, 432, 433, 434, 435, 436, 437, 438,
 439, 430, 427, 445,-160,-148,-159, -38,-160, 277,
 282, 499,-146,  46, 278, -68, -69,-146, 282, 280,
 -69,-126,-152,-126,-152,-126,-152, -82, -84,-113,
 406,-124, -96, 125, -91, -41, 361, -81,  59,  44,
-174, 406, 123,  41,-129,-142, 409, 423, 423, 406,
 406, 406,  93,  44,  40,  40,  40,  40,  40,  40,
  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,
  40,  40,  40,  40,  40,  40,  40,  40,  40,  40,
  40,  40,  40,  40,-128,  40,-128,  40,  40,-171,
  59, 123,-152,-173, 123,  44,-152,-157, -38, 423,
  59,  44,  61, -40,  42,  40, -10, 423,-158, -11,
  91,-123, -94,  40, 409,-120, -39, 123, 271, 123,
 123,-108,-150, 307, 123, 125,-113,  41,-171, 125,
 -91, 125,  58,  59, -62,-134, -73, 502,  41, -30,
 -29, 258,  41,-127,  44,  41,  41,  44,  44,-111,
 -50, -49, 406,-176,-177,-140,-151, -70, -25, 279,
 300, 288,-158,-147, -22,-137,-158,-147,  -2, 423,
 -20, -19,-169, -32, -87, -86, -64, -56,  -7, -55,
-143,-145,  -5,-101, -24,-161,  40,-136,-162, 424,
-138,  -6,  33,  38,  42, 126, 423, 409, 410, 411,
 412, 413, 414, 415, 416, 417, 418, 419, 420, 425,
 426, 408, 406, 407, 421, 422,  43,  45, -20, -20,
 -20, -20, -20, -19, -19, -33, -32, -33, -33, -33,
 -33, -33, -33, -33, 406, 406, 406, 406, 409, 413,
 417, -33,-178, 473,  -3, 378, 423,-158, -69, -27,
 -26,-116, -16, -18,  91,-152, -45,  59, -46, -44,
 -39, -65, -71, -12, 123, -32,-161,-173, -10, -39,
  41,  93,  42, -33,  -9, -40,  42, 428, 429,  41,
-175, 423,-173,-173, 123,-168, 423,  40, -53, -52,
-115,-171,  59,-171,-125,-139, -88,-115, 125, -29,
-158,  41, 423,-129, 406, 406,  41,  44, -60, 500,
 501,  41,  41,-152,  41,  41,  41,  41,  44,  63,
 469, 467, 124,  94,  38, 468, 464,  60,  62, 462,
 463, 465, 466,  -6, -99,  42,  47,  37, -38, -57,
 -12,  91,  40, 448,  46, -24,  40,-161,  41,  41,
  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,
  41,  41,  41,  41,  41,  41,  41,  41,  41,  41,
  41, -60,  41, 423,  41, 125, -26, -43, -81, -18,
 -14,-112, -74,-156, -58,-140, -48,-114,-110, 309,
  59,  44, -72, -71,-179, 451, 452, 453, 454, 455,
 456, 457, 458, 459, 460,-133,  40,  41,-119, 291,
  93,  93, 461,  93,  41,  41, 125,  44,-149, -88,
-164,-167,-165,-166, -88, -47,  91,-173,-151,-118,
  44, 423, 360, -88, -38,  59,-127,  44,  41,  41,
 -49,  41,  41, -19, -57, -86, -64, -56,  -7, -55,
-143,-143,-145,-145,-145,-145,  -5,  -5,-101, -24,
-120,  44,  41, -57,  -8, -12, 423, 423, -38,  44,
  41,-171,  59,  59,  93,  44, -44,-118,  44, -12,
-119,  41,-132,-131,-130,-115, -33, 423, 125, -88,
 125,-165, -88,  59, 308, 309,-103,-107,-104,-106,
-105, 308, 309, 423, 125, -52,  61,  58, -90, -89,
 -39,  58,  41,  58,  41, -12,  93,  41,  44,-120,
 -33,-112, 125, -71,  41,  44, -38,  40,  93, 125,
-104,-102,-105, -88,  59, -33,  58,  41, -33,-122,
 -92, -91,  59,  44,  58, -33, -32, -24, -12,  41,
  41, 461,-130, -39, -34, -33, -88,  59,  58, -91,
 -89, -33,  46,  41,  44,  93, -33 };
short YYCONST yydef[]={

  53,  -2, 289,   1, 289,   4,  -2,   0,  13,  14,
  15,  52,   0, 167, 167, 288,   0,   0,   0,  87,
  88,   0,  90, 173, 293,  91,   0,   0,   0,   0,
   0,  68,  69, 326,   2,   3,   0,  -2,  71,  75,
  -2,  86,   0,  57,   0,   0,   0,   0,   0,  46,
   0,   0,   0,   0,   0,   0, 289,  -2,   0, 112,
 115, 116, 121, 122, 123, 124, 125, 126,   0,   0,
 117, 118, 119, 120, 208, 209, 210, 140, 164, 142,
 143, 144, 145, 146, 147, 148, 139, 168, 169, 132,
 155,  65,   0, 152, 154, 156, 150, 283, 284, 285,
 286, 287, 173, 173, 173, 161, 163, 165, 166, 159,
 160,  -2,   0, 289,  37, 292,   0,  79,  81,  77,
  78,   0,   0, 172, 174, 175,   0,   0,   0,   0,
   0,   0, 299, 302, 303, 304, 305, 306, 307, 308,
   0,   0, 320, 321,   0,   0, 325, 336, 337, 338,
 339, 340,   0,   0,   0,   0, 345, 346, 347,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 429,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 354, 355, 356, 357, 436, 436, 396, 397, 398,
 399, 400, 401, 402, 403, 404, 405, 406, 407, 408,
 409, 410, 411, 412, 413, 414, 415, 416, 417, 418,
 419, 420, 421, 422, 423, 424, 425, 426, 427, 428,
 430, 431, 432, 433, 434,   0, 332,   0, 350, 351,
 352, 353,  24,  70,  74,  85,   8,   0,   0,   9,
  22,  10, 167,  11,  21,  12,   0,   0,  25,  60,
  34,  47,  29,  61,  26,   0,   0, 217, 219, 221,
   0,  -2, 235, 237, 239, 240, 241, 242, 243, 244,
 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
 255, 256,   0,   0, 111, 113, 114,  -2, 128, 141,
 162,   0, 157,   0, 151, 153, 155, 156, 164, 149,
 158,   0,  -2,   0,  -2,   0,  -2,   0,  -2,   6,
   0,  24, 289,  31,  33,   0,   0,   0,  76,   0,
 289,   0,   0,  92,   0,  98,  99,  96,   0,   0,
   0,   0, 296, 326,   0, 318, 322,   0,   0,   0,
   0,   0, 393, 393, 393, 393, 393, 393, 393, 393,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 388, 394,   0, 395,   0,   0,   7,
  23,  54,  56, 291,  55,   0,  58, 236, 106, 107,
 105, 236,   0,  -2, 233, 236, 264, 265, 266, 277,
   0,   0, 238,   0, 259,   0, 228,   0,  66, 167,
 167,   0, 192,   0, 289,  24,   5,   0,  18,  30,
  32,  24,  -2,  36,  80,  82,  83,  84,  89,   0,
  64,   0,  93,   0,   0, 100, 101,   0,   0, 298,
   0, 328, 330,   0,   0,   0,   0, 358, 359, 360,
 361,   0, 363,   0, 108, 109, 110,   0,   0, 348,
   0, 391, 392, 445, 449, 451, 453, 455, 457, 459,
 461, 464, 469, 472, 474, 476,   0, 478,   0,   0,
 482, 508, 509, 510, 511, 512, 487, 488, 489, 490,
 491, 492, 493, 494, 495, 496, 497, 498, 499, 500,
 501, 502, 503, 504, 505, 506, 513, 514,   0,   0,
   0,   0,   0,   0,   0,   0, 446,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 333, 334, 335,   0, 291,
  49,   0, 290, 295, 326,  59, 104, 223,   0, 225,
 227, 220, 222, 437,   0, 447, 476,   0, 263,   0,
 276, 278, 511,   0,   0,  -2, 234,   0,   0, 127,
   0, 130, 289, 289, 167, 193, 205,   0, 440, 135,
   0,  16,  17,  19,   0,  -2,  41,   0,  62,  63,
   0,  94,  98,  97,   0,   0, 317,   0,   0, 327,
   0, 324, 341, 362, 342, 343, 344, 364, 393,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 515, 516, 517,  -2,   0,
 443,   0,   0,   0,   0, 479,   0, 481, 365, 366,
 367, 368, 369, 370, 371, 372, 373, 374, 375, 376,
 377, 378, 379, 380, 381, 382, 383, 384, 385, 386,
 387,   0, 435,   0, 349,  24,  48,   0,   0, 294,
   0, 301, 309, 310, 311, 312, 313, 314, 315, 316,
 224, 236, 440, 441,   0, 520, 521, 522, 523, 524,
 525, 526, 527, 528, 529, 276, 289, 260, 262, 275,
 279, 280,   0, 281, 257, 258, 129,   0, 289, 177,
   0,  -2, 184, 289, 187, 188, 326,   0,   0,   0,
  -2, 137,   0,  40,  -2,  67,   0,   0, 102, 103,
 329, 319, 323, 390,   0, 452, 454, 456, 458, 460,
 462, 463, 465, 466, 467, 468, 470, 471, 473, 475,
   0,   0, 507,   0,   0, 518, 485, 486,  -2,   0,
 331,  20,  50,  51, 297, 326, 226,   0, 439, 448,
 261, 267,   0, 269, 271,   0, 282, 131, 170, 176,
 179, 183, 185, 186,   0,   0,   0, 194, 196, 289,
 201,   0,   0,   0, 133, 136,   0,  -2,   0, 211,
 213,   0,  95,   0,   0, 444, 483, 484,   0,   0,
   0, 300, 438, 442, 268, 289,  -2,   0, 289, 181,
 195, 197, 200, 198, 199,   0, 203, 204, 138,  35,
  -2,  45, 178,  -2,   0, 214, 450, 477, 519, 480,
 389,   0, 272, 273,   0, 207, 190, 191, 202,  44,
 212, 215, 270,   0,   0, 189, 206 };
/* SCCSWHAT( "@(#)yypars.c	2.4 88/5/9 15:22:59	" ) */

static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
extern YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
extern short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn	*	pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

#define MAX_RECOVERY_ATTEMPTS	(50)
#define MAX_RETRY_COUNT			(3)
static short RetryCount = 0;
static short MaxRecoveryAttempts = 0;
static short fJustDiscarded = 0;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	RetryCount = 0;

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = (short *) yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		int yytempchar;


		if( (yychar != EOI ) &&
			 ( RetryCount < MAX_RETRY_COUNT ) &&
			 ( MaxRecoveryAttempts < MAX_RECOVERY_ATTEMPTS ) )
			{ 
			if( RetryCount == 0 )
				SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			if((( yytempchar = PossibleMissingToken( yysavestate, yychar ) ) != -1 ))
				{
				char Buf[ 50 ];


				fHaveRecoveredChar	= 1;
				yyunlex( yychar );
				yychar	= yytempchar;

				if( (yytempchar < 128 ) && isprint( yytempchar ) )
					{
					sprintf( Buf, " %c ", yytempchar );
					}
				else if( yytempchar == IDENTIFIER )
					{
					yylval.yy_pSymName = GenTempName();
					sprintf( Buf, " identifier %s", yylval.yy_pSymName );
					}
				else if( (yytempchar == NUMERICCONSTANT ) ||
						 (yytempchar == NUMERICLONGCONSTANT ) ||
						 (yytempchar == NUMERICULONGCONSTANT ) ||
						 (yytempchar == HEXCONSTANT ) ||
						 (yytempchar == HEXLONGCONSTANT ) ||
						 (yytempchar == HEXULONGCONSTANT ) )
					{
					sprintf( Buf, "a number" );
					yylval.yy_numeric.Val = 0;
					yylval.yy_numeric.pValStr = new char[2];
					strcpy( yylval.yy_numeric.pValStr, "0");
					}

				ParseError( ASSUMING_CHAR, Buf );
				RetryCount = 0;
				MaxRecoveryAttempts++;
				fJustDiscarded = 0;
				}
			else 
				{
				char buf[ 20 ];
				if( (yychar < 128 ) && isprint( yychar ) )
					{
					sprintf( buf, " %c ", yychar );
					}
				else
					{
					sprintf( buf, " the last token " );
					}

				ParseError( DISCARDING_CHAR, buf );
				yychar = -1;
				RetryCount++;
				MaxRecoveryAttempts++;
				fJustDiscarded = 1;
				}

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else if( (yychar == EOI ) && (fJustDiscarded == 0 ) )
			{
			SyntaxError( UNEXPECTED_END_OF_FILE, yysavestate );
			return 1;
			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}

static void
case_fn_0001()


{
                node_source *           pSource         = new node_source;


                pSource->SetMembers( yypvt[-0].yy_siblist );
                pSourceNode     = pSource;


                /**
                 ** If there were errors detected in the 1st pass, the dont do
                 ** anything.
                 **/

                if( !pCompiler->GetErrorCount() )
                        {


                        /**
                         ** If we found no errors, the first compiler phase is over
                         **/

                        return;
                        }
                else
                        {

                        // if the errors prevented a resolution pass and semantics
                        // to be performed, then issue a message. For that purpose
                        // look at the node state of the source node. If it indicates
                        // presence of a forward decl, then we must issue the error

                        ParseError( ERRORS_PASS1_NO_PASS2, (char *)0 );
                        }

                /**
                 ** If we reached here, there were errors detected, and we dont
                 ** want to invoke the subsequent passes, Just quit.
                 **/

                pSourceNode     = (node_source *)NULL;
                returnflag      = 1;
                return;

                }

static void
case_fn_0002()
{
            // create file node, add imports

                node_file               *       pFile;
                named_node              *       pN;
                char                    *       pInputFileName;

                /**
                 ** pick up the details of the file, because we need to set the
                 ** file nodes name with this file
                 **/

                pImportCntrl->GetInputDetails( &pInputFileName );

                pFile   = new node_file( pInputFileName, ImportLevel );

                /**
                 ** Attach the interface nodes as a member of the file node.
                 ** Also, point the interface nodes to their parent file node.
                 **/

                pFile->SetMembers( yypvt[-1].yy_intbody.Members );


                MEM_ITER                        MemIter(pFile);


                while ( pN      = MemIter.GetNext() )
                        {
                        pN->SetFileNode( pFile );
                        }

                /**
                 ** we may have collected the more file nodes as part of the reduction
                 ** process. If so, then attach this node to the list. If not then
                 ** generate a new list and attach the file node there
                 **/

                if( yypvt[-1].yy_intbody.Imports )
                        yyval.yy_siblist      = yypvt[-1].yy_intbody.Imports;
                else
                        yyval.yy_siblist.Init();

                yyval.yy_siblist.SetPeer( pFile );
            }

static void
case_fn_0003()
{
                if( !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
                        {
                        ParseError( MULTIPLE_INTF_NON_OSF, NULL );
                        }

                // if we have dangling definitions, add them to the intf
                if ( yypvt[-0].yy_intbody.Members.Tail() &&
             ( !yypvt[-0].yy_intbody.Members.Tail()->IsInterfaceOrObject() ) )
            {
                        node_interface  *   pIntf   =
                                        pInterfaceInfoDict->GetInterfaceNode();

                yyval.yy_intbody = yypvt[-1].yy_intbody;
                        yyval.yy_intbody.Imports.Merge( yypvt[-0].yy_intbody.Imports );
                        pIntf->MergeMembersToTail( yypvt[-0].yy_intbody.Members );
                        if ( yypvt[-1].yy_intbody.Members.Tail() != pIntf )
                            yyval.yy_intbody.Members.Add( pIntf );
                    }
        else
                {
                    // merge interface list and imports list
                    yyval.yy_intbody = yypvt[-1].yy_intbody;
                    yyval.yy_intbody.Imports.Merge( yypvt[-0].yy_intbody.Imports );
                    yyval.yy_intbody.Members.Merge( yypvt[-0].yy_intbody.Members );
                    }
            }

static void
case_fn_0004()
{
                if ( yypvt[-0].yy_intbody.Members.Tail() &&
             ( !yypvt[-0].yy_intbody.Members.Tail()->IsInterfaceOrObject() ) )
            {
                        node_interface  *   pIntf   =
                                        pInterfaceInfoDict->GetInterfaceNode();

                        // gets siblist of declarations
                        pIntf->MergeMembersToTail( yypvt[-0].yy_intbody.Members );
                        yyval.yy_intbody.Imports = yypvt[-0].yy_intbody.Imports;
                        yyval.yy_intbody.Members.Init( pIntf );
                    }
        else
                {
                    // pass interface list and imports list
                    yyval.yy_intbody = yypvt[-0].yy_intbody;
                    }
                }

static void
case_fn_0005()
{
            // merge interface list and imports list
            yyval.yy_intbody = yypvt[-1].yy_intbody;
            yyval.yy_intbody.Imports.Merge( yypvt[-0].yy_intbody.Imports );
            yyval.yy_intbody.Members.Merge( yypvt[-0].yy_intbody.Members );
            }

static void
case_fn_0007()
{

                /**
                 ** This is the place where the complete interface construct
                 ** has been reduced. We need to hook the body to the interface
                 ** and pass it up, with the imports
                 **/

                node_interface  *       pInterface              = yypvt[-3].yy_inthead.pInterface;

                pInterface->SetMembers( yypvt[-2].yy_intbody.Members );

                yyval.yy_intbody.Imports = yypvt[-2].yy_intbody.Imports;
                yyval.yy_intbody.Members.Init( pInterface );

                /**
                 ** Start a new interface info dict in case there are
                 ** multiple interfaces in this file.
                 **/

                pInterfaceInfoDict->EndNewInterface();
                pInterfaceInfoDict->StartNewInterface();

        // start a dummy interface for intervening stuff
                node_interface *        pOuter  = new node_interface;


                pOuter->SetSymName( GenIntfName() );

                pInterfaceInfoDict->SetInterfaceNode( pOuter );
                pOuter->SetAttribute( new battr( ATTR_LOCAL ) );
                pOuter->SetProcTbl( (ImportLevel != 0) ? new SymTable : pBaseSymTbl );
                }

static void
case_fn_0008()
{

        // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

        // tbd - error if yypvt[-2].yy_attrlist.NonNull()
                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );
                
                if (pFound && pFound->NodeKind() != NODE_HREF && pFound->NodeKind() != NODE_INTERFACE && NULL != pFound->GetDefiningFile())
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }

                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init( pNode );
            }

static void
case_fn_0009()
{

        // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

        // tbd - error if yypvt[-2].yy_attrlist.NonNull()

                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );

                if (pFound && pFound->NodeKind() != NODE_HREF && pFound->NodeKind() != NODE_DISPINTERFACE && NULL != pFound->GetDefiningFile())
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }
                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init( pNode );
            }

static void
case_fn_0010()
{

        // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

        // tbd - error if yypvt[-2].yy_attrlist.NonNull()

                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );
                
                if (pFound && pFound->NodeKind() != NODE_HREF && pFound->NodeKind() != NODE_COCLASS && NULL != pFound->GetDefiningFile())
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }
                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init( pNode );
            }

static void
case_fn_0011()
{

        // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

        // tbd - error if yypvt[-2].yy_attrlist.NonNull()

                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );
                
                if (pFound && pFound->NodeKind() != NODE_HREF && pFound->NodeKind() != NODE_MODULE && NULL != pFound->GetDefiningFile())
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }
                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init( pNode );
            }

static void
case_fn_0012()
{

        // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

        // tbd - error if yypvt[-2].yy_attrlist.NonNull()

                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

        yyval.yy_intbody.Imports.Init();
        yyval.yy_intbody.Members.Init( pNode );
            }

static void
case_fn_0013()
{
                if( !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) &&
                        !((node_file*)yypvt[-0].yy_siblist.Tail())->IsXXXBaseIdl() )
                        {
                        ParseError( OUTSIDE_OF_INTERFACE, NULL );
                        }
                // returns siblist
                // these need to get saved up so they will be added to
                // the header file
                yyval.yy_intbody.Imports = yypvt[-0].yy_siblist;
                yyval.yy_intbody.Members.Init();
                }

static void
case_fn_0014()
{
                if( !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
                        {
                        ParseError( OUTSIDE_OF_INTERFACE, NULL );
                        }

                // pass up a sibling list
                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members = yypvt[-0].yy_siblist;
                }

static void
case_fn_0015()
{
                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init( yypvt[-0].yy_graph );
                }

static void
case_fn_0016()
{
                /**
                 ** This is the place where the complete library construct
                 ** has been reduced. We need to hook the body to the library
                 ** and pass it up, with the imports
                 **/

                node_library  *       pLibrary              = yypvt[-4].yy_libhead.pLibrary;

                pLibrary->SetMembers( yypvt[-2].yy_intbody.Members );

                yyval.yy_intbody.Imports = yypvt[-2].yy_intbody.Imports;
                yyval.yy_intbody.Members.Init( pLibrary );

                // Throw the big "case sensitive again" switch here
                gfCaseSensitive = TRUE;

                // return to the previous Import Level
                ImportLevel--;
                }

static void
case_fn_0017()
{
                if ( !FAddImportLib(yypvt[-2].yy_string) )
                    {
                    ParseError(TYPELIB_NOT_LOADED, yypvt[-2].yy_string);
                    }
                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init();
                }

static void
case_fn_0018()
{
                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol table level
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                node_module * pModule = yypvt[-3].yy_modulehead.pModule;
                pModule->SetMembers(yypvt[-1].yy_siblist);

                yyval.yy_intbody.Members.Init( pModule );
                yyval.yy_intbody.Imports.Init();

                /**
                 ** Start a new interface info dict in case there are
                 ** multiple interfaces in this file.
                 **/

                pInterfaceInfoDict->EndNewInterface();
                pInterfaceInfoDict->StartNewInterface();

        // start a dummy interface for intervening stuff
                node_interface *        pOuter  = new node_interface;

                pOuter->SetSymName( GenIntfName() );

                pInterfaceInfoDict->SetInterfaceNode( pOuter );
                pOuter->SetAttribute( new battr( ATTR_LOCAL ) );
                pOuter->SetProcTbl( (ImportLevel != 0) ? new SymTable : pBaseSymTbl );
                }

static void
case_fn_0019()
{
                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol table level
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                node_dispinterface * pDispInterface = yypvt[-4].yy_disphead.pDispInterface;
                pDispInterface->SetMembers(yypvt[-2].yy_siblist);

                yyval.yy_intbody.Members.Init(pDispInterface);
                yyval.yy_intbody.Imports.Init();

                /**
                 ** Start a new interface info dict in case there are
                 ** multiple interfaces in this file.
                 **/

                pInterfaceInfoDict->EndNewInterface();
                pInterfaceInfoDict->StartNewInterface();

        // start a dummy interface for intervening stuff
                node_interface *        pOuter  = new node_interface;


                pOuter->SetSymName( GenIntfName() );

                pInterfaceInfoDict->SetInterfaceNode( pOuter );
                pOuter->SetAttribute( new battr( ATTR_LOCAL ) );
                pOuter->SetProcTbl( (ImportLevel != 0) ? new SymTable : pBaseSymTbl );
                }

static void
case_fn_0020()
{
                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol table level
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                char * szName = yypvt[-5].yy_string;
                node_coclass * pCoclass = new node_coclass();
                pCoclass->AddAttributes(yypvt[-6].yy_attrlist);
                pCoclass->SetSymName(szName);
                pCoclass->SetMembers( yypvt[-2].yy_siblist);

                // add coclass node to the global symbol table

                SymKey SKey (szName, NAME_DEF);
                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );
                //if (pFound && ( pFound->NodeKind() == NODE_FORWARD || pFound->NodeKind() == NODE_HREF ))
                if (pFound && ( pFound->NodeKind() == NODE_FORWARD || NULL != pFound->GetDefiningFile() ))
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }

                if (!pBaseSymTbl->SymInsert(SKey, (SymTable *) NULL, pCoclass))
                {
                    ParseError(DUPLICATE_DEFINITION, szName);
                }

                yyval.yy_intbody.Members.Init( pCoclass );
                yyval.yy_intbody.Imports.Init();
                }

static void
case_fn_0021()
{
                char * szName = yypvt[-1].yy_string;
                node_module * pModule = new node_module();
                pModule->AddAttributes(yypvt[-2].yy_attrlist);
                pModule->SetSymName(szName);

                // modules get a private scope for procs
                pModule->SetProcTbl(new SymTable);

                // start the new module
                pInterfaceInfoDict->SetInterfaceNode(pModule);

                // add module node to the base symbol table

                SymKey SKey (szName, NAME_DEF);
                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );
                //if (pFound && ( pFound->NodeKind() == NODE_FORWARD || pFound->NodeKind() == NODE_HREF ))
                if (pFound && ( pFound->NodeKind() == NODE_FORWARD || NULL != pFound->GetDefiningFile() ))
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }

                if (!pBaseSymTbl->SymInsert(SKey, (SymTable *) NULL, pModule))
                {
                    ParseError(DUPLICATE_DEFINITION, szName);
                }

                yyval.yy_modulehead.pModule = pModule;
                }

static void
case_fn_0022()
{
                char * szName = yypvt[-1].yy_string;
                node_dispinterface * pDispInterface = new node_dispinterface();
                pDispInterface->AddAttributes(yypvt[-2].yy_attrlist);
                pDispInterface->SetSymName(szName);

                // dipatchinterfaces get a private scope for procs
                pDispInterface->SetProcTbl(new SymTable);

                // start the new dispatchinterface
                pInterfaceInfoDict->SetInterfaceNode(pDispInterface);

                // add dispinterface node to the global symbol table

                SymKey SKey (szName, NAME_DEF);
                named_node * pFound;
                pFound = pBaseSymTbl->SymSearch( SKey );
                //if (pFound && ( pFound->NodeKind() == NODE_FORWARD || pFound->NodeKind() == NODE_HREF ))
                if (pFound && ( pFound->NodeKind() == NODE_FORWARD || NULL != pFound->GetDefiningFile() ))
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }

                if (!pBaseSymTbl->SymInsert(SKey, (SymTable *) NULL, pDispInterface))
                {
                    ParseError(DUPLICATE_DEFINITION, szName);
                }

                yyval.yy_disphead.pDispInterface = pDispInterface;
                }

static void
case_fn_0025()
{
                // make sure that only one library statement exists

                char * szName = yypvt[-1].yy_string;

                if (fLibrary)
                {
                    ParseError(TWO_LIBRARIES, szName);
                }
                fLibrary = TRUE;

                // create library node

                node_library * pLibrary = new node_library();

                yyval.yy_libhead.pLibrary = pLibrary;

                pLibrary->AddAttributes(yypvt[-2].yy_attrlist);
                pLibrary->SetSymName(szName);

                // throw the big "case insensitive" switch here
                gfCaseSensitive = FALSE;

                // Bump the Import Level to ensure that interfaces under the
                // library statement are treated correctly.
                ImportLevel++;
   }

static void
case_fn_0026()
{
                yyval.yy_string = yypvt[-0].yy_string;
                }

static void
case_fn_0028()
{
                // initialize and return an empty list
                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members.Init();
                }

static void
case_fn_0029()
{
                yyval.yy_string = yypvt[-0].yy_string;
                }

static void
case_fn_0031()
{
                yyval.yy_siblist.Init();
                }

static void
case_fn_0032()
{
                yyval.yy_siblist.Merge(yypvt[-0].yy_siblist);
                }

static void
case_fn_0034()
{
                yyval.yy_string = yypvt[-0].yy_string;
                }

static void
case_fn_0035()
{
                yyval.yy_siblist = yypvt[-3].yy_siblist;
                yyval.yy_siblist.Merge(yypvt[-0].yy_siblist);
                // Can I tell where the properties stop and the methods begin?
                // And does it really matter?
                }

static void
case_fn_0036()
{
                // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

                // tbd - error if yypvt[-1].yy_string.NonNull()

                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

                yyval.yy_siblist.Init( pNode );
                }

static void
case_fn_0037()
{
                yyval.yy_siblist.Init();
                }

static void
case_fn_0039()
{
                yyval.yy_siblist.Init();
                }

static void
case_fn_0040()
{
                yyval.yy_siblist.Merge(yypvt[-0].yy_siblist);
                }

static void
case_fn_0043()
{
                yyval.yy_siblist.Init();
                }

static void
case_fn_0044()
{
                yyval.yy_siblist.Merge(yypvt[-0].yy_siblist);
                }

static void
case_fn_0046()
{
                yypvt[-0].yy_siblist.AddAttributes(yypvt[-1].yy_attrlist);
                yyval.yy_siblist = yypvt[-0].yy_siblist;

                /**
                 ** Check to see if it has a property attribute.
                 ** If it does, remove its name from the symbol table,
                 ** decorate it with the appropriate decoration
                 ** and re-insert it into the symbol table
                 **/

                BOOL fPropPut = FALSE;
                BOOL fPropGet = FALSE;
                BOOL fPropPutRef = FALSE;
                node_base_attr * pCur = yypvt[-1].yy_attrlist.GetFirst();
                named_node * pNode = yyval.yy_siblist.Tail();
                char * szName = pNode->GetSymName();

                while (pCur)
                    {
                    if (pCur->GetAttrID() == ATTR_MEMBER)
                        {
                        switch(((node_member_attr *)pCur)->GetAttr())
                            {
                            case MATTR_PROPPUT:
                                fPropPut = TRUE;
                                if (fPropGet | fPropPutRef)
                                    ParseError(MULTIPLE_PROPERTY_ATTRIBUTES, szName);
                                break;
                            case MATTR_PROPGET:
                                fPropGet = TRUE;
                                if (fPropPut | fPropPutRef)
                                    ParseError(MULTIPLE_PROPERTY_ATTRIBUTES, szName);
                                break;
                            case MATTR_PROPPUTREF:
                                fPropPutRef = TRUE;
                                if (fPropGet | fPropPut)
                                    ParseError(MULTIPLE_PROPERTY_ATTRIBUTES, szName);
                                break;
                            }
                        }
                    pCur = pCur->GetNext();
                    }

                if (fPropPut | fPropGet | fPropPutRef)
                    {
                    // remove the name from the correct symbol table
                    SymKey SKey(szName, NAME_PROC);
                    SymTable * pSymTable = pInterfaceInfoDict->GetInterfaceProcTable();
                    named_node * pFound = pSymTable->SymSearch(SKey);
                    if (pNode == pFound)
                        {
                        pSymTable->SymDelete(SKey);
                        char * szNewName;
                        if (fPropPut)
                        {
                            szNewName = new char[strlen(szName) + 5];
                            sprintf(szNewName , "put_%s", szName);
                        }
                        else
                        if (fPropGet)
                        {
                            szNewName = new char[strlen(szName) + 5];
                            sprintf(szNewName , "get_%s", szName);
                        }
                        else
                        {
                            szNewName = new char[strlen(szName) + 8];
                            sprintf(szNewName , "putref_%s", szName);
                        }
                        pFound->SetSymName(szNewName);
                        SymKey SNewKey(szNewName, NAME_PROC);
                        pSymTable->SymInsert(SNewKey, (SymTable *)NULL, pFound);
                        }
                    else
                        ParseError(ILLEGAL_USE_OF_PROPERTY_ATTRIBUTE, szName);
                    }
                }

static void
case_fn_0047()
{
                yyval.yy_string = yypvt[-0].yy_string;
                }

static void
case_fn_0048()
{
                yyval.yy_siblist.Merge(yypvt[-0].yy_siblist);
                }

static void
case_fn_0050()
{
                // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

                // tbd - error if yypvt[-1].yy_string.NonNull()

                if(!pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }

                // bugbug - how to I verify that the name actually belongs to a DispInterface?
                yyval.yy_siblist.Init( pNode );
                yyval.yy_siblist.AddAttributes(yypvt[-2].yy_attrlist);
                }

static void
case_fn_0051()
{
                // put in a forward declaration

                SymKey                      SKey( yypvt[-1].yy_string, NAME_DEF );
                named_node  *       pNode;

                pNode   = new node_forward( SKey, pBaseSymTbl );
                pNode->SetSymName( yypvt[-1].yy_string );

                // tbd - error if yypvt[-1].yy_string.NonNull()

                if(!pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pNode ))
                        {
                        // ParseError( DUPLICATE_DEFINITION, pName );
                        }
                // bugbug - how to I verify that the name actually belongs to an Interface?
                yyval.yy_siblist.Init( pNode );
                yyval.yy_siblist.AddAttributes(yypvt[-2].yy_attrlist);
                }

static void
case_fn_0052()
{
                /* force the lexer to return   import "oaidl.idl";
                 */
                if ( !fOdlBaseImported)
                    {
                    /* Make sure the MS_EXT and C_EXT switches get defined
                     */
                    pCommand->SwitchDefined( SWITCH_MS_EXT );
                    pCommand->SwitchDefined( SWITCH_C_EXT );
                    // make sure the change sticks
                    pCommand->SetModeSwitchConfigMask();
                    LexContext = LEX_ODL_BASE_IMPORT;
                    fOdlBaseImported = TRUE;
                    }
            }

static void
case_fn_0053()
{
                /* force the lexer to return   import "idlbase.idl" ;
                 * in the first interface
                 */
                if ( !fBaseImported )
                        {
                        if( pCommand->IsSwitchDefined( SWITCH_IDLBASE ) )
                                LexContext = LEX_BASE_IMPORT2;

                        fBaseImported = TRUE;
                        }

                node_interface *        pOuter  = new node_interface;

                pOuter->SetSymName( GenIntfName() );

                pInterfaceInfoDict->SetInterfaceNode( pOuter );
                pOuter->SetAttribute( new battr( ATTR_LOCAL ) );
                pOuter->SetProcTbl( (ImportLevel != 0) ? new SymTable : pBaseSymTbl );
                }

static void
case_fn_0054()
{
                node_interface_reference        *       pRef;
                char                    *                               pName = yypvt[-2].yy_string;
                node_interface *                                pIntf = new node_interface();

                yyval.yy_inthead.pInterface                   = pIntf;
                pIntf->AddAttributes( yypvt[-3].yy_attrlist );

				// interfaces with inheritance implicitly become object interfaces now...
				if ( yypvt[-1].yy_graph )
					{
					if ( !pIntf->FInSummary( ATTR_OBJECT ) )
						{
						pIntf->SetAttribute( ATTR_OBJECT );
						}
					}

                // object intfs get a private scope for procs, imported intfs, too
                if ( pIntf->FInSummary( ATTR_OBJECT ) ||
                     ( ImportLevel != 0 ) )
                    pIntf->SetProcTbl( new SymTable );
                else
                        pIntf->SetProcTbl( pBaseSymTbl );

                pIntf->SetSymName( pName );
                if ( !strcmp( pName, "IUnknown" ) )
                        pIntf->SetValidRootInterface();

                pRef = new node_interface_reference( pIntf );


                // add the interface reference node to the base symbol table as if
                // it were a typedef
                SymKey                  SKey( pName, NAME_DEF );

                named_node  *   pFound;

                pFound = pBaseSymTbl->SymSearch( SKey );
                //if ( pFound && ( pFound->NodeKind() == NODE_FORWARD || pFound->NodeKind() == NODE_HREF) )
                if (pFound && ( pFound->NodeKind() == NODE_FORWARD || NULL != pFound->GetDefiningFile() ))
                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }

                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pRef ))
                    {
                    ParseError( DUPLICATE_DEFINITION, pName );
                    }


                // set the base interface of this interface
                // this MAY be a node_forward
                pIntf->SetMyBaseInterfaceReference( (named_node *) yypvt[-1].yy_graph );

                // start the new interface

                pInterfaceInfoDict->SetInterfaceNode( pIntf );
                }

static void
case_fn_0055()
{
                node_interface_reference        *       pRef;
                char                    *                               pName = yypvt[-2].yy_string;
                node_object             *                               pIntf = new node_object();

                yyval.yy_inthead.pInterface                   = pIntf;
                pIntf->AddAttributes( yypvt[-3].yy_attrlist );

                // objects get a private scope for procs
            pIntf->SetProcTbl( new SymTable );

                pIntf->SetSymName( pName );

                pRef = new node_interface_reference( pIntf );


                // add the interface reference node to the base symbol table as if
                // it were a typedef
                SymKey                  SKey( pName, NAME_DEF );

                named_node  *   pFound;

                pFound = pBaseSymTbl->SymSearch( SKey );
                //if ( pFound && ( pFound->NodeKind() == NODE_FORWARD || pFound->NodeKind() == NODE_HREF ))
                if (pFound && ( pFound->NodeKind() == NODE_FORWARD || NULL != pFound->GetDefiningFile() ))

                    {
                    pBaseSymTbl->SymDelete( SKey );
                    }

                if(!pBaseSymTbl->SymInsert( SKey, (SymTable *)NULL, pRef ))
                        {
                        ParseError( DUPLICATE_DEFINITION, pName );
                        }


                // set the base interface list of this object
                // this MAY include node_forwards
                pIntf->SetMyBaseInterfaceList( yypvt[-1].yy_tnlist );

                // start the new interface/object

                pInterfaceInfoDict->SetInterfaceNode( pIntf );
                }

static void
case_fn_0056()
{

                node_skl        *       pNode;
                SymKey                  SKey( yypvt[-0].yy_string, NAME_DEF );
                BOOL                    fNotFound       =
                                                        ! ( pNode = pBaseSymTbl->SymSearch( SKey ) );

                if( fNotFound || (pNode->NodeKind() == NODE_FORWARD ) )
                        {
                        pNode   = new node_forward( SKey, pBaseSymTbl );
                        ((named_node *)pNode)->SetSymName( yypvt[-0].yy_string );
                        }

                //Return a node_forward or a node_interface_reference.
                yyval.yy_graph = pNode;
                }

static void
case_fn_0057()
{
                yyval.yy_graph = NULL;
                }

static void
case_fn_0058()
{

                node_skl        *       pNode;
                SymKey                  SKey( yypvt[-0].yy_string, NAME_DEF );
                BOOL                    fNotFound       =
                                                        ! ( pNode = pBaseSymTbl->SymSearch( SKey ) );

                if( fNotFound || (pNode->NodeKind() == NODE_FORWARD ) )
                        {
                        pNode   = new node_forward( SKey, pBaseSymTbl );
                        ((named_node *)pNode)->SetSymName( yypvt[-0].yy_string );
                        }

                //Return a new list with a node_forward or a node_interface_reference.
                yyval.yy_tnlist      = new type_node_list;
                if( pNode )
                        yyval.yy_tnlist->SetPeer( pNode );
                }

static void
case_fn_0059()
{
                node_skl        *       pNode;
                SymKey                  SKey( yypvt[-0].yy_string, NAME_DEF );
                BOOL                    fNotFound       =
                                                        ! ( pNode = pBaseSymTbl->SymSearch( SKey ) );

                if( fNotFound || (pNode->NodeKind() == NODE_FORWARD ) )
                        {
                        pNode   = new node_forward( SKey, pBaseSymTbl );
                        ((named_node *)pNode)->SetSymName( yypvt[-0].yy_string );
                        }

                //Add a node_forward or a node_interface_reference to the list.
                yyval.yy_tnlist = yypvt[-2].yy_tnlist;
                yyval.yy_tnlist->SetPeer(pNode);
                }

static void
case_fn_0060()
{
        yyval.yy_string = yypvt[-0].yy_string;
        }

static void
case_fn_0061()
{
                // complain if they werent supposed to use these
                if ( !pCommand->IsComClassOK() )
                        ParseError( UNDEFINED_SYMBOL, "class" );
                yyval.yy_string = yypvt[-0].yy_string;
                }

static void
case_fn_0062()
{
                node_com_server         *       pServer = new node_com_server( yypvt[-3].yy_string );

                pServer->SetServerType( yypvt[-4].yy_short );
                pServer->SetClassList( yypvt[-1].yy_tnlist );

                yyval.yy_graph = pServer;
                }

static void
case_fn_0063()
{
                yyval.yy_tnlist = yypvt[-1].yy_tnlist;
                yyval.yy_tnlist->SetPeer( yypvt[-0].yy_graph );
                }

static void
case_fn_0064()
{
                type_node_list  *       pList   = new type_node_list( yypvt[-0].yy_graph );
                yyval.yy_tnlist = pList;
                }

static void
case_fn_0066()
{
            char * szType = yypvt[-0].yy_graph->GetSymName();
            node_skl * pNode = (named_node *)AddQualifiedReferenceToType(yypvt[-2].yy_pSymName, szType);
            if (!pNode)
            {
                char * sz = new char [strlen(yypvt[-2].yy_pSymName) + strlen(szType) + 2];
                strcpy(sz, yypvt[-2].yy_pSymName);
                strcat(sz, ".");
                strcat(sz, szType);
                ParseError( UNDEFINED_SYMBOL, sz);
                pNode = yypvt[-0].yy_graph;
            }
            yyval.yy_graph = pNode;
            }

static void
case_fn_0067()
{
                yyval.yy_graph = yypvt[-1].yy_graph;
                }

static void
case_fn_0068()
{
                // complain if they werent supposed to use these
                if ( !pCommand->IsComClassOK() )
                        ParseError( UNDEFINED_SYMBOL, "dllserver" );

                yyval.yy_short = COM_SERVER_IS_DLL;
                }

static void
case_fn_0069()
{
                // complain if they werent supposed to use these
                if ( !pCommand->IsComClassOK() )
                        ParseError( UNDEFINED_SYMBOL, "exeserver" );

                yyval.yy_short = COM_SERVER_IS_EXE;
                }

static void
case_fn_0070()
{

                /**
                 ** This production is reduced when there is at least 1 imported
                 ** file
                 **/

                yyval.yy_intbody.Imports      = yypvt[-1].yy_siblist;
                yyval.yy_intbody.Members      = yypvt[-0].yy_siblist;

                }

static void
case_fn_0071()
{

                /**
                 ** This production is reduced when there is NO import in the file
                 **/

                yyval.yy_intbody.Imports.Init();
                yyval.yy_intbody.Members      = yypvt[-0].yy_siblist;
                }

static void
case_fn_0073()
{
          yyval.yy_siblist.Init();
          }

static void
case_fn_0074()
{
                yyval.yy_siblist      = yypvt[-1].yy_siblist;
                yyval.yy_siblist.Merge( yypvt[-0].yy_siblist );
                }

static void
case_fn_0076()
{
                yyval.yy_siblist      = yypvt[-1].yy_siblist;
                }

static void
case_fn_0077()
{
                yyval.yy_siblist      = yypvt[-0].yy_siblist;
                ((node_file*)yyval.yy_siblist.Tail()) ->SetXXXBaseIdl();
                }

static void
case_fn_0078()
{
                yyval.yy_siblist      = yypvt[-0].yy_siblist;
                }

static void
case_fn_0080()
{
                yyval.yy_siblist      = yypvt[-2].yy_siblist;
                yyval.yy_siblist.Merge( yypvt[-0].yy_siblist );
                }

static void
case_fn_0081()
{

                /**
                 ** we just obtained the import file name as a string. Immediately
                 ** following, we must switch the input from the imported file.
                 **/

                // push the current case sensitive setting on the stack
                gCaseStack.Push(gfCaseSensitive);

                // switch to case sensitive mode
                gfCaseSensitive = TRUE;

                pImportCntrl->PushLexLevel();

                if( pImportCntrl->SetNewInputFile( yypvt[-0].yy_string ) != STATUS_OK )
                        {
                        yyval.yy_siblist.Init();
                        returnflag      = 1;
                        return;
                        }

                /**
                 ** update the quick reference import level indicator
                 **/

                ImportLevel++;

                // the new file gets its own Zp stack

                PushZpStack( pPackStack, CurrentZp );

                // prepare for anything not in an interface body
                pInterfaceInfoDict->StartNewInterface();

                node_interface *        pOuter  = new node_interface;

                pOuter->SetSymName( GenIntfName() );

                pInterfaceInfoDict->SetInterfaceNode( pOuter );
                pOuter->SetAttribute( new battr( ATTR_LOCAL ) );
                pOuter->SetProcTbl( (ImportLevel != 0) ? new SymTable : pBaseSymTbl );

                }

static void
case_fn_0082()
{

                /**
                 ** The phantom interface production is introduced to unify the actions
                 ** from a successful and unsuccessful import. An import can be
                 ** errorneous if the file being imported has been imported before.
                 **/

                BOOL    fError  = !( ( yyval.yy_siblist = yypvt[-0].yy_siblist ).NonNull() );

                /**
                 ** Restore the lexical level of the import controller.
                 **/

                pImportCntrl->PopLexLevel();
                pInterfaceInfoDict->EndNewInterface();

                // return to the enclosing files Zp stack
                PopZpStack( pPackStack, CurrentZp );

                ImportLevel--;

                //
                // The filehandler will return an end of file if the file was a
                // redundant import OR there was a genuine end of file. It will set
                // a flag, fRedundantImport to differentiate between the two situations.
                // Report different syntax errors in both these cases.
                //

                if( fError )
                        {
                        if( fRedundantImport )
                                ParseError( REDUNDANT_IMPORT, yypvt[-2].yy_string );
                        else
                                {
                                ParseError( UNEXPECTED_END_OF_FILE, yypvt[-2].yy_string );
                                }
                        }
                fRedundantImport = FALSE;

                // pop the previous case sensitive mode back off the stack
                gCaseStack.Pop(gfCaseSensitive);
                }

static void
case_fn_0083()
{

                /**
                 ** InputFile is a list of file nodes
                 **/
                char * pInputFileName;

                yyval.yy_siblist      = yypvt[-0].yy_siblist;
                pImportCntrl->GetInputDetails( &pInputFileName );

                AddFileToDB( pInputFileName );

                }

static void
case_fn_0084()
{
                yyval.yy_siblist.Init();
                }

static void
case_fn_0085()
{
                yyval.yy_siblist      = yypvt[-1].yy_siblist;
                yyval.yy_siblist.Merge( yypvt[-0].yy_siblist );
                }

static void
case_fn_0087()
{
                yyval.yy_siblist.Init(yypvt[-0].yy_graph);
                }

static void
case_fn_0088()
{
                yyval.yy_siblist.Init(yypvt[-0].yy_graph);
                }

static void
case_fn_0089()
{
                ParseError( CPP_QUOTE_NOT_OSF, (char *)0 );

                yypvt[-1].yy_string      = MakeNewStringWithProperQuoting( yypvt[-1].yy_string );

                yyval.yy_siblist.Init( new node_echo_string( yypvt[-1].yy_string ) );
                }

static void
case_fn_0091()
{

                /**
                 ** we need to emit the c pragma strings as they are.
                 ** we introduce the echo string node, so that the back end can
                 ** emit it without even knowing the difference.
                 **/

#define PRAGMA_PACK_STRING      ("#pragma pack( ")
#define PRAGMA_STRING   ("#pragma ")



                char    *       p = new char [ strlen( yypvt[-0].yy_string ) + strlen( PRAGMA_STRING ) + 1 ];
                strcpy( p, PRAGMA_STRING );
                strcat( p, yypvt[-0].yy_string );
                yyval.yy_graph      = new node_echo_string( p );
                }

static void
case_fn_0092()
{
                node_pragma_pack    *   pPack;
                /* return to global packing level */
                pPack = new node_pragma_pack( NULL,
                                    pCommand->GetZeePee(),
                                    PRAGMA_PACK_RESET );
                CurrentZp = pCommand->GetZeePee();

        yyval.yy_graph = pPack;
                }

static void
case_fn_0093()
{
                /* set current packing level */
                if ( yypvt[-1].yy_short )
                    {
                        node_pragma_pack    *   pPack;
                        /* switch top to new packing level */
                        pPack = new node_pragma_pack( NULL,
                                            0,
                                            PRAGMA_PACK_SET,
                                        yypvt[-1].yy_short );
            CurrentZp = yypvt[-1].yy_short;
                yyval.yy_graph = pPack;
                    }
                else
                    yyval.yy_graph = NULL;
                }

static void
case_fn_0094()
{

                node_pragma_pack    *   pPack;

        switch( yypvt[-2].yy_short )
            {
            case PRAGMA_PACK_PUSH:
                {
                // do push things
                // push current zp
                                /* switch top to new packing level */
                                pPack = new node_pragma_pack( NULL,
                                                    CurrentZp,
                                                    PRAGMA_PACK_PUSH,
                                            yypvt[-1].yy_short );
                        pPack->Push( pPackStack );

                        yyval.yy_graph = pPack;
                if ( yypvt[-1].yy_short )
                    CurrentZp = yypvt[-1].yy_short;
                break;
                }
            case PRAGMA_PACK_POP:
                {
                // do pop things
                                /* switch top to new packing level */
                                pPack = new node_pragma_pack( NULL,
                                                    yypvt[-1].yy_short,
                                                    PRAGMA_PACK_POP );
                        CurrentZp = pPack->Pop( pPackStack );

                        if ( !CurrentZp )
                            {
                            CurrentZp = pCommand->GetZeePee();
                            ParseError(MISMATCHED_PRAGMA_POP, NULL );
                            }
                        yyval.yy_graph = pPack;
                break;
                }
            default:
                yyval.yy_graph = NULL;
            }
                }

static void
case_fn_0095()
{

                node_pragma_pack    *   pPack;

        switch( yypvt[-4].yy_short )
            {
            case PRAGMA_PACK_PUSH:
                {
                // do push things
                // push current zp
                                /* switch top to new packing level */
                                pPack = new node_pragma_pack( yypvt[-2].yy_pSymName,
                                                    CurrentZp,
                                                    PRAGMA_PACK_PUSH,
                                            yypvt[-1].yy_short );
                        pPack->Push( pPackStack );

                        yyval.yy_graph = pPack;
                if ( yypvt[-1].yy_short )
                    CurrentZp = yypvt[-1].yy_short;
                break;
                }
            case PRAGMA_PACK_POP:
                {
                // do pop things
                                /* switch top to new packing level */
                                pPack = new node_pragma_pack( yypvt[-2].yy_pSymName,
                                                    yypvt[-1].yy_short,
                                                    PRAGMA_PACK_POP );
                        CurrentZp = pPack->Pop( pPackStack );

                        if ( !CurrentZp )
                            {
                            CurrentZp = pCommand->GetZeePee();
                            ParseError(MISMATCHED_PRAGMA_POP, NULL );
                            }
                        yyval.yy_graph = pPack;
                break;
                }
            default:
                yyval.yy_graph = NULL;
            }

                }

static void
case_fn_0096()
{
                if ( !strcmp( yypvt[-0].yy_pSymName, "push" ) )
                    {
                        yyval.yy_short      = PRAGMA_PACK_PUSH;
                    }
                else if ( !strcmp( yypvt[-0].yy_pSymName, "pop" ) )
                    {
                        yyval.yy_short      = PRAGMA_PACK_POP;
                    }
                else
                    {
                        ParseError( UNKNOWN_PRAGMA_OPTION, yypvt[-0].yy_pSymName);
                        yyval.yy_short = PRAGMA_PACK_GARBAGE;
                    }
        }

static void
case_fn_0097()
{
        yyval.yy_short = yypvt[-0].yy_short;
                }

static void
case_fn_0098()
{
        yyval.yy_short = 0;
        }

static void
case_fn_0099()
{
                  switch ( yypvt[-0].yy_numeric.Val )
                        {
                        case 1:
                        case 2:
                        case 4:
                        case 8:
                            yyval.yy_short = (short) yypvt[-0].yy_numeric.Val;
                                break;
                        default:
                                ParseError( UNKNOWN_PRAGMA_OPTION, yypvt[-0].yy_numeric.pValStr);
                                yyval.yy_short = 0;
                        }
                }

static void
case_fn_0100()
{

                /**
                 ** We need to set import on and off here
                 **/

                char    *       p;

                if( strcmp( yypvt[-1].yy_pSymName, "off" ) == 0 )
                        {
                        p       = "/* import off */";
                        fPragmaImportOn = FALSE;
                        }
                else if( strcmp( yypvt[-1].yy_pSymName, "on" ) == 0 )
                        {
                        p       = "/* import on */";
                        fPragmaImportOn = TRUE;
                        }
                else
                        p       = "/* import unknown */";

                yyval.yy_graph      = new node_echo_string( p );

                }

static void
case_fn_0101()
{


                yypvt[-1].yy_string      = MakeNewStringWithProperQuoting( yypvt[-1].yy_string );

                yyval.yy_graph      = new node_echo_string( yypvt[-1].yy_string );

                }

static void
case_fn_0102()
{

                yyval.yy_graph      = NULL;

                }

static void
case_fn_0103()
{

                yyval.yy_graph      = NULL;

                }

static void
case_fn_0104()
{

                /**
                 ** create new typedef nodes for each of the declarators, apply any
                 ** type attributes to the declarator. The declarators will have a
                 ** basic type as specied by the Declaration specifiers.
                 ** Check for the presence of a init expression. The typedef derives
                 ** the declarators from the same place as the other declarators, so
                 ** an init list must be explicitly checked for and reported as a
                 ** syntax error. But dont report errors for each declarator, instead
                 ** report it only once at the end.
                 **/

                class _DECLARATOR               *       pDec;
                char                                    *       pName;
                node_skl                                *       pType;
                DECLARATOR_LIST_MGR             pDeclList( yypvt[-0].yy_declarator_set );
                /**
                 ** prepare for a list of typedefs to be made into interface
                 ** components
                 **/

                 yyval.yy_siblist.Init();

                while( pDec = pDeclList.DestructiveGetNext() )
                        {

                        node_def_fe * pDef = (node_def_fe *) pDec->pHighest;
                        pType = yypvt[-1].yy_declspec.pNode;
        
                        if (NULL == pDef)
                            {
                            /**
                             ** The declaration is a forward declaration following the
                             ** goofy mktyplib syntax:  typedef struct foo; (or union).
                             ** We need to verify that the mktyplib203 switch is set
                             ** (only allow this syntax in mktyplib compatibility mode)
                             ** and we need to create a forward declaration so that 
                             ** future references will resolve correctly.
                             **/
                            
                            pName = pType->GetSymName();
                            SymKey  SKey( pName, NAME_DEF );
                            node_forward * pFwd = new node_forward( SKey, pCurSymTbl );
                            pFwd->SetSymName( pName );
                            
                            pDef = new node_def_fe(pName, pFwd);
                            pDec->Init(pDef);
                            
                            if (!pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
                                ParseError( ILLEGAL_USE_OF_MKTYPLIB_SYNTAX, pName);
                            }
                        else
                            { 
                            pName = pDef->GetSymName();
                            }

                        /**
                         ** set the basic type of the declarator.
                         **/
                        
                        pDec->pLowest->SetChild( pType );


                        // complain about invalid redef of wchar_t or error_status_t
                        
                        if (pName)
                            {
                            if ( strcmp( pName, "wchar_t" ) == 0 )
                                {
                                node_skl        *       pN = pType;
                                if( !((pN->NodeKind() == NODE_SHORT) &&
                                           pN->FInSummary( ATTR_UNSIGNED) ) )
                                        {
                                        ParseError( WCHAR_T_ILLEGAL, (char *)0 );
                                        }
                                }
                            else if( strcmp( pName, "error_status_t" ) == 0 )
                                {
                                node_skl        *       pN = pType;
                                if( !((pN->NodeKind() == NODE_LONG) &&
                                           pN->FInSummary( ATTR_UNSIGNED) ) )
                                        {
                                        ParseError( ERROR_STATUS_T_ILLEGAL, (char *)0 );
                                        }
                               }
                            }
                        else
                            ParseError( BENIGN_SYNTAX_ERROR, "" );
                        //
                        // if the type specifier is a forward declared type, then
                        // the only syntax allowed is when context_handle is applied
                        // to the type. If not, report an error
                        //

//gaj                   CheckSpecialForwardTypedef( pDef, pType, yypvt[-2].yy_attrlist);


                        /**
                         ** The typedef node graph is all set up,
                         ** apply attributes and enter into symbol table
                         **/


                        yyval.yy_siblist.Add( pDef );
     
                        /**
                         ** Remember that we have to apply the attributes to each of
                         ** the declarators, so we must clone the attribute list for
                         ** each declarator, the apply the type attribute list to each
                         ** of the declarators
                         **/

                        if ( yypvt[-2].yy_attrlist.NonNull() )
                                {
                                
                                pDef->AddAttributes( yypvt[-2].yy_attrlist );
                       
                  
                                }
            
                        /**
                         ** similarly, apply the remnant attributes collected from
                         ** declaration specifiers, to the declarator
                         **
                         ** Only the first declarator to use a composite type gets to
                         ** be the declaration; all the others reference that declaration;
                         ** e.g.  struct FOO { xxx } foo, *pfoo
                         ** is treated as: struct FOO { xxx } foo
                         **                                struct FOO *pfoo
                         **/
#ifdef gajdebug11
                        printf("setting modifiers %8x on %s\n",
                                        yypvt[-1].yy_declspec.modifiers,
                                        (pName)? pName : "(unknown)" );
#endif
                        pDec->pLowest->SetModifiers( yypvt[-1].yy_declspec.modifiers );

                        yypvt[-1].yy_declspec.modifiers |= SetModifierBit( ATTR_TAGREF );
                        }
     

                }

static void
case_fn_0105()
{
                /**
                 ** All declarations other than typedefs are collected here.
                 ** They are collected and passed up to the interface component
                 ** production
                 **/
                node_skl                *       pType                   = yypvt[-2].yy_declspec.pNode;
                DECLARATOR_LIST_MGR     DeclList( yypvt[-1].yy_declarator_set );
                long                            TempModifiers;
                long                            TopModifiers;

#ifdef gajdebug3
                printf("DeclarationSpecifiers OptionalInitDeclaratorList\n");
#endif
                yyval.yy_siblist.Init();

                /**
                 ** It is possible that there are no declarators, only a type decla-
                 ** ration. eg, the definition of a structure.
                 **/

                if ( DeclList.NonEmpty() )
                        {
                        class _DECLARATOR       *       pDec;


                        /**
                         ** for each declarator, set the basic type, set the attributes
                         ** if any
                         **/

                        while( pDec     = DeclList.DestructiveGetNext() )
                                {

                                pDec->pLowest->SetChild( pType );

                                /**
                                 ** Apply the remnant attributes from the declaration specifier
                                 ** prodn to this declarator;
                                 **/

                                // magic trick to push extern, etc up to top
                                TempModifiers = yypvt[-2].yy_declspec.modifiers;
                                TopModifiers = TempModifiers & 0x0000000f;
                                TempModifiers -= TopModifiers;

                                pDec->pLowest->SetModifiers( TempModifiers );
                                pDec->pHighest->SetModifiers( TopModifiers );

                                yypvt[-2].yy_declspec.modifiers |= SetModifierBit( ATTR_TAGREF );

                                /**
                                 ** shove the type node up.
                                 **/

                                yyval.yy_siblist.Add( (named_node *) pDec->pHighest );
                                }
                        }
                else
                        {

#ifdef gajdebug3
                        printf("\t\t...no declarators\n");
#endif
                        /**
                         ** This is the case when no specific declarator existed. Just
                         ** pass on the declaration to interface component. However, it
                         ** is possible that the declaration is a forward declaration,
                         ** in that case, just generate a dummy typedef. The dummy typedef
                         ** exists, so that the whole thing is transparent to the back end.
                         **/

                        named_node      *       pDef    = (named_node *) yypvt[-2].yy_declspec.pNode;

                        /**
                         ** Apply the remnant attributes from the declaration specifier
                         ** prodn to this declarator;
                         **/

                        if( yypvt[-2].yy_declspec.modifiers )
                                {
                                pDef->SetModifiers( yypvt[-2].yy_declspec.modifiers );
                                }

                        /**
                         ** shove the type node up.
                         **/

                        yyval.yy_siblist.Add( pDef );

                        }
                }

static void
case_fn_0107()
{
                node_forward    *       pFwd;

                SymKey  SKey( yypvt[-0].yy_pSymName, NAME_DEF );
                pFwd                    = new node_forward( SKey, pCurSymTbl );
                pFwd->SetSymName( yypvt[-0].yy_pSymName );

                yyval.yy_declspec.pNode                = pFwd;
                yyval.yy_declspec.modifiers    = 0;
                }

static void
case_fn_0108()
{
                node_base_type *        pNode;
                GetBaseTypeNode( (node_skl**) &pNode,
                                                 yypvt[-0].yy_type.TypeSign,
                                                 yypvt[-0].yy_type.TypeSize,
                                                 yypvt[-0].yy_type.BaseType);

                yyval.yy_graph = pNode;
                if ( pNode->NodeKind() == NODE_INT )
                        ParseError( BAD_CON_INT, NULL );
                }

static void
case_fn_0111()
{
                yyval.yy_declspec.pNode                = yypvt[-0].yy_declspec.pNode;
                yyval.yy_declspec.modifiers    = yypvt[-1].yy_modifiers | yypvt[-0].yy_declspec.modifiers;
                }

static void
case_fn_0113()
{
                yyval.yy_modifiers      = yypvt[-1].yy_modifiers | yypvt[-0].yy_modifiers;
                }

static void
case_fn_0114()
{
                yyval.yy_modifiers      = yypvt[-1].yy_modifiers | yypvt[-0].yy_modifiers;
                }

static void
case_fn_0117()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_EXTERN);
                }

static void
case_fn_0118()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_STATIC);
                }

static void
case_fn_0119()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_AUTO);
                }

static void
case_fn_0120()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_REGISTER);
                }

static void
case_fn_0121()
{
                node_base_type *        pNode;
                GetBaseTypeNode( (node_skl**) &pNode,
                                                 yypvt[-0].yy_type.TypeSign,
                                                 yypvt[-0].yy_type.TypeSize,
                                                 yypvt[-0].yy_type.BaseType);

                yyval.yy_declspec.pNode = pNode;
                if ( pNode->NodeKind() == NODE_INT )
                        ParseError( BAD_CON_INT, NULL );

                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0122()
{
                yyval.yy_declspec.pNode                = yypvt[-0].yy_graph;
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0125()
{
                yyval.yy_declspec.pNode                = yypvt[-0].yy_graph;
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0126()
{

                /**
                 ** Note that there is no need to check for whether the symbol table
                 ** has the entry or not. If it did not, the TYPENAME token would not
                 ** have come in. If the TYPENAME is for a forward reference, see
                 ** if it has been satisfied; if so, create a NEW typedef that is the
                 ** same, but without the forward reference.
                 **/

                node_def_fe     *       pDef    = (node_def_fe *) yypvt[-0].yy_graph;
                if ( ( pDef->NodeKind() == NODE_DEF ) &&
                         pDef->GetChild() &&
                         ( pDef->GetChild()->NodeKind() == NODE_FORWARD ) )
                        {
                        node_forward    *       pFwd    = (node_forward *) pDef->GetChild();
                        node_skl                *       pNewSkl = pFwd->ResolveFDecl();
                        
                        if ( pNewSkl )
                                {
                                ATTRLIST alist;
                                pDef->GetAttributeList(alist);
                                pDef = new node_def_fe( pDef->GetSymName(), pNewSkl );
                                pDef->SetAttributes(alist);
                                SymKey SKey(pDef->GetSymName(), NAME_DEF);
                                pBaseSymTbl->SymDelete(SKey);
                                pBaseSymTbl->SymInsert(SKey, (SymTable *) NULL, (named_node*) pDef);
                                }
                    };
                
                yyval.yy_declspec.pNode = pDef;
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0127()
{
                node_skl        *       pNode   = pErrorTypeNode;

                if( yypvt[-2].yy_declspec.pNode )
                        {

                        if( yypvt[-1].yy_declarator.pHighest )
                                {
                                yypvt[-1].yy_declarator.pLowest->SetChild( yypvt[-2].yy_declspec.pNode );
                                pNode   = yypvt[-1].yy_declarator.pHighest;
                                if( yypvt[-2].yy_declspec.modifiers )
                                        {
                                        ( (named_node *) yypvt[-1].yy_declarator.pLowest)->SetModifiers( yypvt[-2].yy_declspec.modifiers );
                                        }
                                }
                        else
                                pNode   = yypvt[-2].yy_declspec.pNode;

                        }
                yyval.yy_declspec.pNode = new node_safearray( pNode );
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0128()
{
                node_skl * pNode = pErrorTypeNode;

                if (yypvt[-0].yy_declspec.pNode )
                    {
                    pNode = yypvt[-0].yy_declspec.pNode;
                    }

                yyval.yy_declspec.pNode = new node_pipe( pNode );
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF) ;
            }

static void
case_fn_0129()
{
                ParseError( UNIMPLEMENTED_FEATURE, "bitset" );
                yyval.yy_graph      = pErrorTypeNode;
                }

static void
case_fn_0133()
{
                /**
                 ** We just obtained a complete enum definition. Check for
                 ** duplicate definition and break circular label list;
                 **/

                BOOL                    fFound                          = FALSE;
                BOOL                    fEnumIsForwardDecl      = FALSE;
                node_skl        *       pNode;
                SymKey                  SKey( yypvt[-4].yy_string, NAME_ENUM );

                pNode = pBaseSymTbl->SymSearch( SKey );

                if( fFound = (pNode != (node_skl *) NULL) )
                        fEnumIsForwardDecl      = ( pNode->NodeKind() == NODE_FORWARD || pNode->NodeKind() == NODE_HREF );

                if( fFound && !fEnumIsForwardDecl )
                        {
                        ParseError( DUPLICATE_DEFINITION, yypvt[-4].yy_string );
                        yyval.yy_declspec.pNode        = (node_skl     *)pErrorTypeNode;
                        }
                else
                        {
                        /**
                         ** This is a new definition of enum. Enter into symbol table
                         ** Also, pick up the label graph and attach it.
                         **/

                        node_enum * pEnum =  new node_enum( yypvt[-4].yy_string );


                        yyval.yy_declspec.pNode = pEnum;
                        pEnum->SetMembers( yypvt[-2].yy_enlist.NodeList );

                        /**
                         ** Note that the enum symbol table entry need not have a next
                         ** scope since the enum labels are global in scope.If the enum was
                         ** a forward decl into the symbol table, delete it.
                         **/

                        if( fEnumIsForwardDecl )
                                {
                                pBaseSymTbl->SymDelete( SKey );
                                }

                        pBaseSymTbl->SymInsert( SKey,
                                                                        (SymTable *)NULL,
                                                                        (named_node *) yyval.yy_declspec.pNode );
                        CheckGlobalNamesClash( SKey );

                        }
                // if the enumerator is sparse, report an error if the
                // switch configuration is not correct.

                if( yypvt[-2].yy_enlist.fSparse )
                        ParseError( SPARSE_ENUM, (char *)NULL );

                yyval.yy_declspec.modifiers = 0;
                }

static void
case_fn_0134()
{

                /**
                 ** Search for the enum definition, if not found, return the type
                 ** as a forward declarator node. The semantic analysis will register
                 ** the forward declaration and resolve it when the second pass occurs.
                 ** See TaggedStruct production for a description on why we want to
                 ** enter even a fdecl enum in the symbol table.
                 **/

                SymKey  SKey( yypvt[-0].yy_string, NAME_ENUM );
                BOOL    fNotFound       = ! ( yyval.yy_declspec.pNode = pBaseSymTbl->SymSearch( SKey ) );

                if( fNotFound || (yyval.yy_declspec.pNode->NodeKind() == NODE_FORWARD ) )
                        {
                        yyval.yy_declspec.pNode        = new node_forward( SKey, pBaseSymTbl );
                        }
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0135()
{
            /**
                 ** this is the first label on an enum list.  Set up the circular list
                 ** pointing to the tail, and set it's expr to 0L if there was none
                 **/

                expr_node               *       pExpr;
                node_label              *       pLabel = (node_label *) yypvt[-0].yy_enlab.pLabel;

                pExpr   = (yypvt[-0].yy_enlab.pExpr)
                                                ? yypvt[-0].yy_enlab.pExpr
                                                : GetConstant0();

                pLabel->pExpr   = pExpr;

                yyval.yy_enlist.fSparse              = yypvt[-0].yy_enlab.fSparse;
                yyval.yy_enlist.pPrevLabel   = pLabel;
                yyval.yy_enlist.NodeList.Init( pLabel );
                }

static void
case_fn_0136()
{

                /**
                 ** This is a new label we reduced.
                 **
                 ** if there was an expression associated with the label, use that
                 ** else use the already collected expression, and add 1 to it.
                 **/

                expr_node       *       pExpr = (expr_node *)0;
                node_label      *       pLabel = (node_label *) yypvt[-0].yy_enlab.pLabel;

                pExpr = yypvt[-0].yy_enlab.pExpr;

                // next node has no expression, give it an expression of:
                //              <prev label> + 1;
                if (pExpr == NULL )
                        {
                        expr_named_constant *   pPrev =
                                                new expr_named_constant( yypvt[-2].yy_enlist.pPrevLabel->GetSymName(),
                                                                                                 yypvt[-2].yy_enlist.pPrevLabel );

                        pExpr   = new expr_b_arithmetic(OP_PLUS,
                                                                                        pPrev,
                                                                                        GetConstant1() );
                        }

                pLabel->pExpr = pExpr;

                yyval.yy_enlist = yypvt[-2].yy_enlist;

                yyval.yy_enlist.NodeList.Add( pLabel );

                yyval.yy_enlist.pPrevLabel    =      pLabel;
                yyval.yy_enlist.fSparse              +=      yypvt[-0].yy_enlab.fSparse;
                }

static void
case_fn_0137()
{

                /**
                 ** We have obtained an enum label, without an expression. Since
                 ** we dont know if this is the first label (most probably not),
                 ** we just indicate the absence of an expression by an NULL pointer.
                 ** The next parse state would know if this was the first or not
                 ** and take appropriate action
                 **
                 ** The enum labels go into the global name space. Search for
                 ** duplicates on the base symbol table.
                 **/

                node_label      *       pLabel;
                SymKey                  SKey( yypvt[-0].yy_pSymName, NAME_LABEL );

                if( pBaseSymTbl->SymSearch( SKey ) )
                        {
                        ParseError( DUPLICATE_DEFINITION, yypvt[-0].yy_pSymName );
                        pLabel  = new node_label( GenTempName(), NULL );
                        }
                else
                        {

                        /**
                         ** If the label has an expression, use it, else it is 0. Also
                         ** propogate the expression to $$, so that the next labels will
                         ** get it. Note that we DO NOT evaluate the expressions here.
                         ** The MIDL compiler will evaluate the expressions later.
                         **/

                        pLabel  = new node_label( yypvt[-0].yy_pSymName, NULL );

                        /**
                         ** Insert into the global table
                         **/

                        pBaseSymTbl->SymInsert(SKey, (SymTable *)NULL,(named_node *)pLabel);
                        CheckGlobalNamesClash( SKey );

                        }

                if ( yypvt[-1].yy_attrlist.NonNull() )
                        {
                        pLabel->AddAttributes( yypvt[-1].yy_attrlist );
                        }

                yyval.yy_enlab.pLabel       = pLabel;
                yyval.yy_enlab.pExpr        = NULL;
                yyval.yy_enlab.fSparse      = 0;

                }

static void
case_fn_0138()
{

                /**
                 ** This enum label has an expression associated with it. Use it.
                 ** sparse enums are illegal in osf mode
                 **/

                node_label      *       pLabel;
                SymKey                  SKey( yypvt[-2].yy_pSymName, NAME_LABEL );

				if (yypvt[-0].yy_expr->IsStringConstant())
					ParseError(ENUM_TYPE_MISMATCH, yypvt[-2].yy_pSymName);

                if( pBaseSymTbl->SymSearch( SKey ) )
                        {
                        ParseError( DUPLICATE_DEFINITION, yypvt[-2].yy_pSymName );
                        pLabel  = new node_label( GenTempName(), NULL );
                        }
                else
                        {

                        /**
                         ** If the label has an expression, use it, else it is 0. Also
                         ** propogate the expression to $$, so that the next labels will
                         ** get it. Note that we DO NOT evaluate the expressions. The MIDL
                         ** compiler will just dump the expressions for the c compiler to
                         ** evaluate.
                         **/

                        pLabel  = new node_label( yypvt[-2].yy_pSymName, yypvt[-0].yy_expr );

                        /**
                         ** Insert into the global table
                         **/

                        pBaseSymTbl->SymInsert(SKey, (SymTable *)NULL,(named_node *)pLabel);
                        CheckGlobalNamesClash( SKey );

                        }

                if ( yypvt[-3].yy_attrlist.NonNull() )
                        {
                        pLabel->AddAttributes( yypvt[-3].yy_attrlist );
                        }

                yyval.yy_enlab.pLabel       = pLabel;
                yyval.yy_enlab.pExpr        = yypvt[-0].yy_expr;
                yyval.yy_enlab.fSparse      = 1;

                }

static void
case_fn_0139()
{
                ParseError( UNIMPLEMENTED_TYPE, KeywordToString( yypvt[-0].yy_short ) );
                yyval.yy_graph      = (node_skl *)pErrorTypeNode;
                }

static void
case_fn_0140()
{
                yyval.yy_type.BaseType     = TYPE_FLOAT;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0141()
{
                yyval.yy_type.BaseType     = TYPE_DOUBLE;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0142()
{
                yyval.yy_type.BaseType     = TYPE_DOUBLE;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0143()
{
                yyval.yy_type.BaseType     = TYPE_VOID;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0144()
{
                yyval.yy_type.BaseType     = TYPE_BOOLEAN;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0145()
{
                yyval.yy_type.BaseType     = TYPE_BYTE;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0146()
{
                yyval.yy_type.BaseType     = TYPE_HANDLE_T;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0147()
{
                yyval.yy_type      = yypvt[-0].yy_type;
                if( yyval.yy_type.BaseType == TYPE_UNDEF )
                        yyval.yy_type.BaseType = TYPE_INT;
                if( yyval.yy_type.TypeSign == SIGN_UNDEF )
                        {
                        if( (yyval.yy_type.TypeSize != SIZE_SMALL) && (yyval.yy_type.TypeSize != SIZE_CHAR) )
                                yyval.yy_type.TypeSign = SIGN_SIGNED;
                        }
                }

static void
case_fn_0148()
{
                yyval.yy_type.BaseType     = TYPE_INT;
                yyval.yy_type.TypeSign     = yypvt[-0].yy_type.TypeSign;
                yyval.yy_type.TypeSize     = SIZE_CHAR;
                }

static void
case_fn_0149()
{
                yyval.yy_type.TypeSign     = yypvt[-1].yy_type.TypeSign;
                }

static void
case_fn_0150()
{
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                }

static void
case_fn_0151()
{
                BaseTypeSpecAnalysis( &(yypvt[-1].yy_type), TYPE_INT );
                }

static void
case_fn_0153()
{
                yyval.yy_type                      = yypvt[-0].yy_type;
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                }

static void
case_fn_0154()
{
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0155()
{
                yyval.yy_type.TypeSign     = SIGN_UNDEF;
                yyval.yy_type.TypeSize     = yypvt[-0].yy_short;
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                }

static void
case_fn_0157()
{
                yyval.yy_type.TypeSign     = yypvt[-0].yy_type.TypeSign;
                yyval.yy_type.TypeSize     = yypvt[-1].yy_short;
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                }

static void
case_fn_0158()
{
                yyval.yy_type.TypeSign     = yypvt[-1].yy_type.TypeSign;
                yyval.yy_type.TypeSize     = yypvt[-0].yy_short;
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                }

static void
case_fn_0159()
{
                ParseError(SIGNED_ILLEGAL, (char *)0);
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                yyval.yy_type.TypeSign     = SIGN_SIGNED;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0160()
{
                yyval.yy_type.BaseType     = TYPE_UNDEF;
                yyval.yy_type.TypeSign     = SIGN_UNSIGNED;
                yyval.yy_type.TypeSize     = SIZE_UNDEF;
                }

static void
case_fn_0161()
{
                yyval.yy_short      = SIZE_HYPER;
                }

static void
case_fn_0162()
{
                yyval.yy_short      = SIZE_LONGLONG;
                }

static void
case_fn_0163()
{
                yyval.yy_short      = SIZE_HYPER;
                }

static void
case_fn_0164()
{
                yyval.yy_short      = SIZE_LONG;
                }

static void
case_fn_0165()
{
                yyval.yy_short      = SIZE_SHORT;
                }

static void
case_fn_0166()
{
                yyval.yy_short      = SIZE_SMALL;
                }

static void
case_fn_0167()
{

                /**
                 ** We just obtained a starter for a new scope. Push the
                 ** symbol table to the next level for the rest of the including
                 ** production
                 **/
                pSymTblMgr->PushSymLevel( &pCurSymTbl );

                }

static void
case_fn_0170()
{

                /**
                 ** The entire struct was sucessfully reduced. Attach the fields as
                 ** members of the struct. Insert a new symbol table entry for the
                 ** struct and attach the lower scope of the symbol table to it.
                 ** Check for dupliate structure definition
                 **/

                BOOL                            fFound                                  = FALSE;
                BOOL                            fStructIsForwardDecl    = FALSE;
                node_struct             *       pStruct;
                SymTable                *       pSymLowerScope                  = pCurSymTbl;
                SymKey                          SKey( yypvt[-4].yy_string, NAME_TAG );

                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol table level
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                /**
                 ** if this is a duplicate definition, dont do anything. Note that
                 ** the struct tag name shares the global name space with enum and
                 ** union tag names.
                 **/

                pStruct = (node_struct *) pBaseSymTbl->SymSearch( SKey );

                if( fFound = ( pStruct != (node_struct *)NULL ) )
                        fStructIsForwardDecl = (pStruct->NodeKind() == NODE_FORWARD || pStruct->NodeKind() == NODE_HREF);

                if( fFound && !fStructIsForwardDecl )
                        {
                        ParseError( DUPLICATE_DEFINITION, yypvt[-4].yy_string );
                        pStruct = (node_struct *)pErrorTypeNode;
                        }
                else
                        {

                        /**
                         ** this is a valid entry. Build the graph for it and
                         ** enter into symbol table. If the struct entry was present as
                         ** a forward decl, delete it
                         **/

                        if( fStructIsForwardDecl )
                                {
                                pBaseSymTbl->SymDelete( SKey );
                                }

                        pStruct = new node_struct( yypvt[-4].yy_string );
                        pStruct->SetMembers( yypvt[-1].yy_siblist );
                        pStruct->SetZeePee( CurrentZp );

                        pBaseSymTbl->SymInsert( SKey, pSymLowerScope, pStruct );
                        CheckGlobalNamesClash( SKey );
                        }
                yyval.yy_declspec.pNode                = pStruct;
                yyval.yy_declspec.modifiers    = 0;

                }

static void
case_fn_0171()
{

                /**
                 ** This is the invocation of a struct. If the struct was not
                 ** defined as yet, then return a forward declarator node. The
                 ** semantics will register the forward declaration and resolve it.
                 ** But there is a loop hole in this. If we do not enter the struct into
                 ** the symbol table, the user may define a union/enum of the same name.
                 ** We will let him, since we do not yet have an entry in the symbol
                 ** table. We will then never check for duplication, since the parser
                 ** is the only place we check for this. We will then generate wrong
                 ** code, with the struct and a union/enum with the same name !! The
                 ** solution is to enter a symbol entry with a fdecl node as the type
                 ** graph of the struct.
                 **/

                SymKey  SKey( yypvt[-0].yy_string, NAME_TAG );
                named_node      *       pNode =  pBaseSymTbl->SymSearch( SKey );

                if( !pNode || (pNode->NodeKind() == NODE_FORWARD ) )
                        {
                        pNode   = new node_forward( SKey, pBaseSymTbl );
                        pNode->SetSymName( yypvt[-0].yy_string );
                        }
                yyval.yy_declspec.pNode = pNode;

                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0173()
{
                yyval.yy_string      = GenCompName();
                }

static void
case_fn_0174()
{
                yyval.yy_string      = yypvt[-0].yy_pSymName;
                }

static void
case_fn_0175()
{
                //yyval.yy_string    = yypvt[-0].yy_graph;
                yyval.yy_string = yypvt[-0].yy_graph->GetCurrentSpelling();
                }

static void
case_fn_0176()
{
                yyval.yy_siblist.Merge( yypvt[-0].yy_siblist );
                }

static void
case_fn_0178()
{

                /**
                 ** This is a complete field declaration. For each declarator,
                 ** set up a field with the basic type as the declaration specifier,
                 ** apply the field attributes, and add to the list of fields for the
                 ** struct / union
                 ** field
                 **/

                class _DECLARATOR               *       pDec;
                node_skl                                *       pType;
                DECLARATOR_LIST_MGR                     DeclList( yypvt[-1].yy_declarator_set );


                yyval.yy_siblist.Init();
                while( pDec = DeclList.DestructiveGetNext() )
                        {

                        node_field                              *       pField = (node_field *) pDec->pHighest;

                        /**
                         ** if the field was a bit field, we need to set up some additional
                         ** info.
                         **/


                        pType = yypvt[-2].yy_declspec.pNode;
                        pDec->pLowest->SetChild( pType );

                        /**
                         ** Apply the field attributes and set the field as part of the
                         ** list of fields of the struct/union
                         **/

                        if ( yypvt[-3].yy_attrlist.NonNull() )
                                {

                                pField->AddAttributes( yypvt[-3].yy_attrlist );


                                }


                        /**
                         ** similarly, apply the remnant attributes collected from
                         ** declaration specifiers, to the declarator
                         **/

                        if( yypvt[-2].yy_declspec.modifiers )
                                {
                                pDec->pLowest->SetModifiers( yypvt[-2].yy_declspec.modifiers );
                                };


                        /**
                         ** shove the type graph up
                         **/

                        yyval.yy_siblist.Add( pField );

                        }

                }

static void
case_fn_0179()
{

                /**
                 ** The union bosy has been completely reduced. Attach the fields as
                 ** members, insert a new symbol table entry for the union
                 **/

                BOOL                    fFound                                  = FALSE;
                BOOL                    fUnionIsForwardDecl             = FALSE;
                node_union      *       pUnion;
                SymTable        *       pSymLowerScope                  = pCurSymTbl;
                SymKey                  SKey( yypvt[-4].yy_string, NAME_UNION );

                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol table level
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                /**
                 ** if this is a duplicate definition, dont do anything, else
                 ** enter into the symbol table, attach members. Note that the
                 ** symbol table search is actually a search for the tag becuase
                 ** the union tag shares the same name as the struct/enum names
                 **/

                pUnion = (node_union *)pBaseSymTbl->SymSearch( SKey );

                if( fFound = (pUnion != (node_union *) NULL ) )
                        fUnionIsForwardDecl = ( pUnion->NodeKind() == NODE_FORWARD || pUnion->NodeKind() == NODE_HREF );

                if( fFound && !fUnionIsForwardDecl )
                        {
                        ParseError( DUPLICATE_DEFINITION, yypvt[-4].yy_string );
                        pUnion  = (node_union *)pErrorTypeNode;
                        }
                else
                        {

                        /**
                         ** This is a valid entry, build the type graph and insert into
                         ** the symbol table. Delete the entry first if it was a forward
                         ** decl.
                         **/

                        pUnion  = new node_union( yypvt[-4].yy_string );
                        pUnion->SetMembers( yypvt[-1].yy_siblist );

                        if( fUnionIsForwardDecl )
                                {
                                pBaseSymTbl->SymDelete( SKey );
                                }

                        pBaseSymTbl->SymInsert( SKey, pSymLowerScope, pUnion );
                        CheckGlobalNamesClash( SKey );

                        }

                /**
                 ** pass this union up
                 **/

                pUnion->SetZeePee( CurrentZp );
                yyval.yy_declspec.pNode                = pUnion;
                yyval.yy_declspec.modifiers    = 0;

                }

static void
case_fn_0180()
{

                /**
                 ** this is an invocation of the union. If the union was not defined
                 ** then return a forward declarator node as the type node. The
                 ** semantics will register the forward declaration and resolve it
                 ** later. See TaggedStruct production for an explanation why we want to
                 ** enter even a forward declaration into the symbol table.
                 **/

                SymKey                  SKey( yypvt[-0].yy_string, NAME_UNION );
                named_node      *       pNode =  pBaseSymTbl->SymSearch( SKey );

                if( !pNode || (pNode->NodeKind() == NODE_FORWARD ) )
                        {
                        pNode   = new node_forward( SKey, pBaseSymTbl );
                        pNode->SetSymName( yypvt[-0].yy_string );
                        }
                yyval.yy_declspec.pNode = pNode;
                yyval.yy_declspec.modifiers = SetModifierBit(ATTR_TAGREF);
                }

static void
case_fn_0181()
{

                /**
                 ** The union body has been completely reduced. Attach the fields as
                 ** members, insert a new symbol table entry for the union
                 **/

                BOOL                            fFound                                  = FALSE;
                BOOL                            fStructIsForwardDecl    = FALSE;
                node_en_union   *       pUnion;
                SymTable                *       pSymLowerScope                  = pCurSymTbl;

                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol table level
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                pUnion  = new node_en_union( GenCompName() );
                pUnion->SetMembers( yypvt[-1].yy_siblist );

                SymKey                          SKey( pUnion->GetSymName(), NAME_UNION );

                pBaseSymTbl->SymInsert( SKey, pSymLowerScope, pUnion );
                CheckGlobalNamesClash( SKey );

                //
                // The union is inserted into the base symbol table.
                // Now insert into the base symbol table, a new struct entry
                // corresponding to the struct entry that the encapsulated union
                // results in.
                //

                pSymTblMgr->PushSymLevel( &pCurSymTbl );

                SIBLING_LIST            Fields;
                node_field              *       pSwitchField    = (node_field *) yypvt[-4].yy_en_switch.pNode;
                node_field              *       pUnionField             = new node_field;
                node_switch_type *      pSwType                 = new node_switch_type(
                                                                                                        pSwitchField->GetChild() );

                if( IsTempName( yypvt[-4].yy_en_switch.pName ) )
                        yypvt[-4].yy_en_switch.pName        = "tagged_union";
                pUnionField->SetSymName( yypvt[-4].yy_en_switch.pName );
                pUnionField->SetChild( pUnion );

                Fields.Init( pSwitchField );
                Fields.Add( pUnionField );

                //
                // apply the switch_is attribute to the union field.
                //

                pUnionField->SetAttribute( yypvt[-4].yy_en_switch.pSwitch );

                // and the switch_type attribute to the union itself

                pUnion->SetAttribute( pSwType );

                //
                // current symbol table is pointing to a new scope. Enter the two
                // fields into this scope.
                //

                SKey.SetKind( NAME_MEMBER );
                SKey.SetString( pSwitchField->GetSymName() );

                pCurSymTbl->SymInsert( SKey, (SymTable *)0, pSwitchField );
                CheckGlobalNamesClash( SKey );

                SKey.SetString( pUnionField->GetSymName() );

                pCurSymTbl->SymInsert( SKey, (SymTable *)0, pUnionField );
                CheckGlobalNamesClash( SKey );

                pSymLowerScope  = pCurSymTbl;

                pSymTblMgr->PopSymLevel( &pCurSymTbl );

                //
                // create a new structure entry and enter into the symbol table.
                //

                node_struct * pStruct;
                SKey.SetKind( NAME_UNION );
                SKey.SetString( yypvt[-5].yy_string );

                pStruct = (node_struct *)pBaseSymTbl->SymSearch( SKey );

                if( fFound = ( pStruct != (node_struct *)NULL ) )
                        fStructIsForwardDecl = (pStruct->NodeKind() == NODE_FORWARD || pStruct->NodeKind() == NODE_HREF );

                if( fFound && !fStructIsForwardDecl )
                        {
                        ParseError( DUPLICATE_DEFINITION, yypvt[-5].yy_string );
                        pStruct = (node_struct *)pErrorTypeNode;
                        }
                else
                        {

                        /**
                         ** this is a valid entry. Build the graph for it and
                         ** enter into symbol table. If the struct entry was present as
                         ** a forward decl, delete it
                         **/

                        // enter the struct as a union.

                        SKey.SetKind( NAME_UNION );
                        SKey.SetString( yypvt[-5].yy_string );

                        if( fStructIsForwardDecl )
                                {
                                pBaseSymTbl->SymDelete( SKey );
                                }

                        pStruct = new node_en_struct( yypvt[-5].yy_string );
                        pStruct->SetMembers( Fields );
                        pStruct->SetZeePee( CurrentZp );

                        pBaseSymTbl->SymInsert( SKey, pSymLowerScope, pStruct );
                        CheckGlobalNamesClash( SKey );

                        }

                pUnion->SetZeePee( CurrentZp );
                yyval.yy_declspec.pNode                = pStruct;
                yyval.yy_declspec.modifiers    = 0;

                }

static void
case_fn_0183()
{
                (yyval.yy_siblist = yypvt[-1].yy_siblist).Merge( yypvt[-0].yy_siblist );
                }

static void
case_fn_0185()
{

                /**
                 ** for each of the fields, attach the case label attribute.
                 **/

                named_node              *       pNode;
                SIBLING_ITER            MemIter( yypvt[-0].yy_siblist );

                yyval.yy_siblist = yypvt[-0].yy_siblist;

                while( pNode = MemIter.Next() )
                        {
                        pNode->SetAttribute( yypvt[-1].yy_attr );
                        }
                }

static void
case_fn_0186()
{
                /**
                 ** An empty arm. Allocate a field with a node_error as a basic type
                 ** and set the attribute as a case label
                 **/

                node_field              *       pField  = new node_field( GenTempName() );

                pField->SetChild( pErrorTypeNode );
                pField->SetAttribute( yypvt[-1].yy_attr );

                /**
                 ** Generate a list of union fields and add this to the list of
                 ** union fields
                 **/

                yyval.yy_siblist.Init( pField );

                }

static void
case_fn_0187()
{
                /**
                 ** A member declaration without a case label
                 **/
                yyval.yy_siblist      = yypvt[-0].yy_siblist;
                }

static void
case_fn_0189()
{
                yyval.yy_attr      = new node_case( yypvt[-2].yy_exprlist );
                }

static void
case_fn_0190()
{
                named_node      *       pNode;
                SIBLING_ITER    MemIter( yypvt[-0].yy_siblist );

                yyval.yy_siblist = yypvt[-0].yy_siblist;

                while( pNode = MemIter.Next() )
                        {
                        pNode->SetAttribute( ATTR_DEFAULT );
                        }
                }

static void
case_fn_0191()
{

                /**
                 ** This is a default with an empty arm. Set up a dummy field.
                 ** The upper productions will then mark set field with a
                 ** default attribute during semantic analysis. The type of this field
                 ** is set up to be an error node for uniformity.
                 **/

                node_field      *       pField  = new node_field( GenTempName() );

                pField->SetAttribute( ATTR_DEFAULT );
                pField->SetChild( pErrorTypeNode );
                yyval.yy_siblist.Init( pField );

                }

static void
case_fn_0192()
{
                yyval.yy_en_switch                      = yypvt[-0].yy_en_switch;
                yyval.yy_en_switch.pName        = GenCompName();
                }

static void
case_fn_0193()
{
                yyval.yy_en_switch                      = yypvt[-1].yy_en_switch;
                yyval.yy_en_switch.pName        = yypvt[-0].yy_pSymName;
                }

static void
case_fn_0194()
{
                yyval.yy_siblist = yypvt[-0].yy_nucases.CaseList;
                if( yypvt[-0].yy_nucases.DefCount > 1 )
                        ParseError( TWO_DEFAULT_CASES, (char *)0 );
                }

static void
case_fn_0195()
{
                yyval.yy_nucases.DefCount += yypvt[-0].yy_nucases.DefCount;
                yyval.yy_nucases.CaseList.Merge( yypvt[-0].yy_nucases.CaseList );
                }

static void
case_fn_0197()
{
                named_node * pNode;

                //
                // set the case and default attributes.
                //

                yyval.yy_nucases.CaseList     = yypvt[-0].yy_siblist;

                if( yypvt[-1].yy_nucllist.pExprList && yypvt[-1].yy_nucllist.pExprList->GetCount() )
                        {
                        SIBLING_ITER    CaseIter( yypvt[-0].yy_siblist );

                        while( pNode = CaseIter.Next() )
                                {
                                pNode->SetAttribute( new node_case( yypvt[-1].yy_nucllist.pExprList ));
                                }
                        }

                //
                // pick up default attribute. pick up the count of number of
                // times the user specified default so that we can report the
                // error later.
                // Let the default case list count travel upward to report an
                // error when the total list of case labels is seen.
                //


                if( yypvt[-1].yy_nucllist.pDefault && ( yyval.yy_nucases.DefCount = yypvt[-1].yy_nucllist.DefCount ) )
                        {
                        SIBLING_ITER    CaseIter( yypvt[-0].yy_siblist );

                        while( pNode = CaseIter.Next() )
                                {
                                pNode->SetAttribute( yypvt[-1].yy_nucllist.pDefault );
                                }
                        }
                }

static void
case_fn_0199()
{

                node_field * pNode = new node_field( GenTempName() );
                pNode->SetChild( pErrorTypeNode );

                yyval.yy_siblist.Init( pNode );
                }

static void
case_fn_0200()
{
                if( yypvt[-0].yy_nucaselabel.pExpr )
                        yyval.yy_nucllist.pExprList->SetPeer( yypvt[-0].yy_nucaselabel.pExpr );

                if( !(yyval.yy_nucllist.pDefault) )
                        yyval.yy_nucllist.pDefault = yypvt[-0].yy_nucaselabel.pDefault;
                if( yypvt[-0].yy_nucaselabel.pDefault )
                        yyval.yy_nucllist.DefCount++;
                }

static void
case_fn_0201()
{
                yyval.yy_nucllist.pExprList = new expr_list;

                if( yypvt[-0].yy_nucaselabel.pExpr )
                        yyval.yy_nucllist.pExprList->SetPeer( yypvt[-0].yy_nucaselabel.pExpr );
                if( yyval.yy_nucllist.pDefault = yypvt[-0].yy_nucaselabel.pDefault)
                        {
                        yyval.yy_nucllist.DefCount = 1;
                        }
                }

static void
case_fn_0202()
{
                yyval.yy_nucaselabel.pExpr = yypvt[-1].yy_expr;
                yyval.yy_nucaselabel.pDefault = 0;
                }

static void
case_fn_0203()
{
                yyval.yy_nucaselabel.pExpr = 0;
                yyval.yy_nucaselabel.pDefault = new battr( ATTR_DEFAULT );
                }

static void
case_fn_0204()
{
                node_field *    pField = new node_field( yypvt[-1].yy_pSymName );

                yyval.yy_en_switch.pSwitch      =  new node_switch_is( new expr_variable( yypvt[-1].yy_pSymName, pField ));
                yyval.yy_en_switch.pNode = pField;
                pField->SetChild( yypvt[-2].yy_graph );
                pField->SetModifiers( SetModifierBit( ATTR_TAGREF ) );
                }

static void
case_fn_0206()
{
                yyval.yy_exprlist->SetPeer( yypvt[-0].yy_expr );
                }

static void
case_fn_0207()
{
                yyval.yy_exprlist      = new expr_list;
                yyval.yy_exprlist->SetPeer( yypvt[-0].yy_expr );
                }

static void
case_fn_0208()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_VOLATILE);
                }

static void
case_fn_0209()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_CONST);
                }

static void
case_fn_0210()
{
                yyval.yy_modifiers = SetModifierBit(ATTR_C_INLINE);
                }

static void
case_fn_0211()
{
                yyval.yy_declarator_set.Init( yypvt[-0].yy_declarator );
                }

static void
case_fn_0212()
{
                yyval.yy_declarator_set = yypvt[-2].yy_declarator_set;
                yyval.yy_declarator_set.Add( yypvt[-0].yy_declarator );
                }

static void
case_fn_0213()
{

                /**
                 ** a declarator without bit fields specified; a plain field.
                 **/

                if ( (yypvt[-0].yy_declarator.pHighest == NULL)
                        || ( yypvt[-0].yy_declarator.pHighest->NodeKind() != NODE_ID ))
                        {
                        node_def_fe * pDef = new node_def_fe( GenTempName(), pErrorTypeNode );

                        // gaj - report error
                        ParseError( BENIGN_SYNTAX_ERROR, "expecting a declarator");
                        }
                else
                        {

                        // convert top node of declarator chain to node_field
                        // and add the field to the symbol table

                        node_field *    pField = new node_field(
                                                                                (node_id_fe *) yypvt[-0].yy_declarator.pHighest );
                        char *                  pName  = pField->GetSymName();
                        SymKey                  SKey( pName, NAME_MEMBER );


                        yyval.yy_declarator.pHighest     = pField;

                        // if the top node was the only node, set pLowest accordingly
                        yyval.yy_declarator.pLowest      =  ( yypvt[-0].yy_declarator.pLowest == yypvt[-0].yy_declarator.pHighest ) ?
                                pField : yypvt[-0].yy_declarator.pLowest ;

                        delete (node_id_fe *) yypvt[-0].yy_declarator.pHighest;

                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pField ) )
                                {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }
                        else
                                CheckGlobalNamesClash( SKey );
                        };
                }

static void
case_fn_0214()
{

                /**
                 ** This is a declarator specified without the field name
                 **/

                node_bitfield * pField = new node_bitfield();
                char *                  pName = GenTempName();

                pField->SetSymName(pName);

                yyval.yy_declarator.pHighest = pField;
                yyval.yy_declarator.pLowest  = pField;

                // add the field to the symbol table
                SymKey                  SKey( pName, NAME_MEMBER );

                if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pField ) )
                        {
                        ParseError( DUPLICATE_DEFINITION, pName );
                        }
                else
                        CheckGlobalNamesClash( SKey );

                pField->fBitField       = (unsigned char)yypvt[-0].yy_expr->Evaluate();

                }

static void
case_fn_0215()
{

                /**
                 ** The complete bit field specification.
                 **/

                if ( (yypvt[-2].yy_declarator.pHighest == NULL)
                        || ( yypvt[-2].yy_declarator.pHighest->NodeKind() != NODE_ID ))
                        {
                        // gaj - report error
                        }
                else
                        {
                        // convert top node of declarator chain to node_field
                        node_bitfield * pField = new node_bitfield( (node_id_fe *) yypvt[-2].yy_declarator.pHighest );
                        char *           pName  = pField->GetSymName();

                        yyval.yy_declarator.pHighest     = pField;

                        // if the top node was the only node, set pLowest accordingly
                        yyval.yy_declarator.pLowest      =  ( yypvt[-2].yy_declarator.pLowest == yypvt[-2].yy_declarator.pHighest ) ? pField : yypvt[-2].yy_declarator.pLowest;


                        delete (node_id_fe *) yypvt[-2].yy_declarator.pHighest;

                        // add the field to the symbol table
                        SymKey                  SKey( pName, NAME_MEMBER );

                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pField ) )
                                {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }
                        else
                                CheckGlobalNamesClash( SKey );

                        pField->fBitField       = (unsigned char)yypvt[-0].yy_expr->Evaluate();
                        }
                }

static void
case_fn_0216()
{
                // this is used for unnamed nested struct references
                node_field * pField             = new node_field();
                char *           pName          = GenTempName();
                pField->SetSymName( pName);

                yyval.yy_declarator.pHighest = pField;
                yyval.yy_declarator.pLowest  = pField;
                }

static void
case_fn_0218()
{
                yyval.yy_declarator_set.Init();
                }

static void
case_fn_0219()
{
                yyval.yy_declarator_set.Init( yypvt[-0].yy_declarator );
                }

static void
case_fn_0220()
{
                yyval.yy_declarator_set = yypvt[-2].yy_declarator_set;
                yyval.yy_declarator_set.Add( yypvt[-0].yy_declarator );
                }

static void
case_fn_0221()
{
                node_id_fe              *       pID     = (node_id_fe *) yypvt[-0].yy_declarator.pHighest;

                /**
                 ** If the top node of the declarator is null, create a dummy ID
                 ** but not if the top is a proc...
                 **/

                if ( (yypvt[-0].yy_declarator.pHighest == NULL)
                        || ( ( yypvt[-0].yy_declarator.pHighest->NodeKind() != NODE_ID )
                                && ( yypvt[-0].yy_declarator.pHighest->NodeKind() != NODE_PROC) ) )
                        {
                        pID = new node_id_fe( GenTempName() );

                        pID->SetChild( yypvt[-0].yy_declarator.pHighest );
                        yyval.yy_declarator.pHighest = pID;
                        yyval.yy_declarator.pLowest  = ( yypvt[-0].yy_declarator.pLowest ) ? yypvt[-0].yy_declarator.pLowest : pID; // in case of null
                        };

           /**
                ** and add the id to the symbol table
                ** for node_proc's, leave original in symbol table
                **/

                if ( yypvt[-0].yy_declarator.pHighest->NodeKind() != NODE_PROC )
                        {
                        char *                  pName  = pID->GetSymName();
                        SymKey                  SKey( pName, NAME_ID );

                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pID ) )
                                {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }
                        else
                                CheckGlobalNamesClash( SKey );
                        }
                }

static void
case_fn_0222()
{
                if ( (yypvt[-2].yy_declarator.pHighest == NULL)
                        || ( yypvt[-2].yy_declarator.pHighest->NodeKind() != NODE_ID ))
                        {
                        // gaj - report error
                        }
                else
                        {
                        node_id_fe      *       pID             = (node_id_fe *) yypvt[-2].yy_declarator.pHighest;

                        // fill in initializer
                        pID->pInit      = yypvt[-0].yy_expr;
                        yyval.yy_declarator = yypvt[-2].yy_declarator;

                        // and add the id to the symbol table

                        char *                  pName  = pID->GetSymName();
                        SymKey                  SKey( pName, NAME_ID );

                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pID ) )
                                {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }
                        else
                                CheckGlobalNamesClash( SKey );
                        };
                }

static void
case_fn_0223()
{
            yyval.yy_declarator_set.Init();
            }

static void
case_fn_0225()
{
                yyval.yy_declarator_set.Init( yypvt[-0].yy_declarator );
                }

static void
case_fn_0226()
{
                yyval.yy_declarator_set = yypvt[-2].yy_declarator_set;
                yyval.yy_declarator_set.Add( yypvt[-0].yy_declarator );
                }

static void
case_fn_0227()
{
                node_def_fe *   pDef;
                char *                  pName;

                if (yypvt[-0].yy_declarator.pHighest == NULL)
                        {
                        // gaj - report error
                        }
                else if ( yypvt[-0].yy_declarator.pHighest->NodeKind() == NODE_PROC )
                        {
                        // build new node_def and attach to top
                        node_proc *             pProc = (node_proc *) yypvt[-0].yy_declarator.pHighest;

                        pName = pProc->GetSymName();
                        pDef  = new node_def_fe( (node_proc *) yypvt[-0].yy_declarator.pHighest );
                        pDef->SetSymName(pName);
                        pDef->SetChild( yypvt[-0].yy_declarator.pHighest );
                        if ( !strcmp(pName, "HRESULT") || !strcmp(pName, "SCODE") )
                                pDef->SetIsHResultOrSCode();

                        yyval.yy_declarator.pHighest = pDef;
                        yyval.yy_declarator.pLowest = yypvt[-0].yy_declarator.pLowest;

                        SymKey SkeyOld( pName, NAME_PROC );
                        pInterfaceInfoDict->GetInterfaceProcTable()->SymDelete( SkeyOld );

                        SymKey                  SKey( pName, NAME_DEF );
                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pDef ) )
                                {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }
                        else
                                CheckGlobalNamesClash( SKey );

                        }
                else if ( yypvt[-0].yy_declarator.pHighest->NodeKind() == NODE_ID )
                        {

                        // convert top node of declarator chain to node_def
                        // and add the def to the symbol table

                        node_def_fe *   pDef = new node_def_fe( (node_id_fe *) yypvt[-0].yy_declarator.pHighest );
                        char *                  pName  = pDef->GetSymName();
                        SymKey                  SKey( pName, NAME_DEF );

                        if ( !pName )
                                pDef->SetSymName( GenTempName() );

                        if ( !strcmp(pName, "HRESULT") || !strcmp(pName, "SCODE") )
                                pDef->SetIsHResultOrSCode();

                        yyval.yy_declarator.pHighest     = pDef;

                        // if the top node was the only node, set pLowest accordingly
                        yyval.yy_declarator.pLowest      =  ( yypvt[-0].yy_declarator.pLowest == yypvt[-0].yy_declarator.pHighest ) ?  pDef : yypvt[-0].yy_declarator.pLowest;

                        delete (node_id_fe *) yypvt[-0].yy_declarator.pHighest;

                        named_node * pFound;

                        // Allow redefinition of imported types.
                        pFound = pBaseSymTbl->SymSearch( SKey );
                        // if (pFound && ( pFound->NodeKind() == NODE_HREF ))
                        if (pFound && ( NULL != pFound->GetDefiningFile() ))
                            {
                            pBaseSymTbl->SymDelete( SKey );
                            }
                
                        if(!pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pDef ))
                                {

                                //
                                // allow benign redef of wchar_t & error_status_t.
                                //

                                if ( ( strcmp( pName, "wchar_t" ) != 0 ) &&
                                     ( strcmp( pName, "error_status_t" ) != 0 ) )
                                        {
                                        ParseError( DUPLICATE_DEFINITION, pName );
                                        }

                                }
                        else
                                {
                                CheckGlobalNamesClash( SKey );
                                }
                        };
                }

static void
case_fn_0229()
{
                yyval.yy_declarator.Init();
                }

static void
case_fn_0230()
{
                // note that leading modifiers eventually attach to the
                // lowest node of the declarator
                yypvt[-0].yy_declarator.pLowest->SetModifiers( yypvt[-1].yy_modifiers );
                yyval.yy_declarator      = yypvt[-0].yy_declarator;
                }

static void
case_fn_0232()
{

                // point dangling declarator2 lowest to pointer highest,
                // set modifiers on Declarator2
                // return declarator2 highest with pointer lowest

                yypvt[-0].yy_declarator.pLowest->SetModifiers(yypvt[-1].yy_modifiers);
                yypvt[-0].yy_declarator.pLowest->SetChild(yypvt[-2].yy_declarator.pHighest);
                yyval.yy_declarator.pLowest  = yypvt[-2].yy_declarator.pLowest;
                yyval.yy_declarator.pHighest = yypvt[-0].yy_declarator.pHighest;

                }

static void
case_fn_0233()
{
                node_pointer * pPtr             = new node_pointer( (node_pointer *) NULL );
                pPtr->SetModifiers( yypvt[-1].yy_modifiers );
#ifdef gajdebug8
                printf("\t\t attaching modifier to lone ptr: %8x\n",yypvt[-1].yy_modifiers);
#endif

                // create node_pointer with modifierlist
                yyval.yy_declarator.Init( pPtr );
                }

static void
case_fn_0234()
{
                node_pointer * pPtr             = new node_pointer( yypvt[-2].yy_declarator.pHighest );
                pPtr->SetModifiers( yypvt[-1].yy_modifiers );

                // create node_pointer, set child, apply modifierlist to it
                yyval.yy_declarator.Init( pPtr, yypvt[-2].yy_declarator.pLowest );
                }

static void
case_fn_0236()
{
                yyval.yy_modifiers = 0;
                }

static void
case_fn_0238()
{
                yyval.yy_modifiers = yypvt[-1].yy_modifiers | yypvt[-0].yy_modifiers;
                }

static void
case_fn_0242()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_FAR);
                ParseError( BAD_CON_MSC_CDECL, "__far" );
                }

static void
case_fn_0243()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_NEAR);
                ParseError( BAD_CON_MSC_CDECL, "__near" );
                }

static void
case_fn_0244()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_HUGE);
                ParseError( BAD_CON_MSC_CDECL, "__huge" );
                }

static void
case_fn_0245()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_MSCUNALIGNED);
                ParseError( BAD_CON_MSC_CDECL, "unaligned" );
                }

static void
case_fn_0246()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_PASCAL);
                ParseError( BAD_CON_MSC_CDECL, "__pascal" );
                }

static void
case_fn_0247()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_FORTRAN);
                ParseError( BAD_CON_MSC_CDECL, "__fortran" );
                }

static void
case_fn_0248()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_CDECL);
                ParseError( BAD_CON_MSC_CDECL, "__cdecl" );
                }

static void
case_fn_0249()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_STDCALL);
                ParseError( BAD_CON_MSC_CDECL, "__stdcall" );
                }

static void
case_fn_0250()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_LOADDS);
                ParseError( BAD_CON_MSC_CDECL, "__loadds" );
                }

static void
case_fn_0251()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_SAVEREGS);
                ParseError( BAD_CON_MSC_CDECL, "__saveregs" );
                }

static void
case_fn_0252()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_FASTCALL);
                ParseError( BAD_CON_MSC_CDECL, "__fastcall" );
                }

static void
case_fn_0253()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_SEGMENT);
                ParseError( BAD_CON_MSC_CDECL, "__segment" );
                }

static void
case_fn_0254()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_INTERRUPT);
                ParseError( BAD_CON_MSC_CDECL, "__interrupt" );
                }

static void
case_fn_0255()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_SELF);
                ParseError( BAD_CON_MSC_CDECL, "__self" );
                }

static void
case_fn_0256()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_EXPORT);
                ParseError( BAD_CON_MSC_CDECL, "__export" );
                }

static void
case_fn_0257()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_DLLIMPORT);
                ParseError( BAD_CON_MSC_CDECL, "__declspec(dllimport)" );
                }

static void
case_fn_0258()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_DLLEXPORT);
                ParseError( BAD_CON_MSC_CDECL, "__declspec(dllexport)" );
                }

static void
case_fn_0259()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_NONE);
                ParseError( BAD_CON_MSC_CDECL, "__emit" );
                }

static void
case_fn_0260()
{
                yyval.yy_declarator      = yypvt[-1].yy_declarator;
                }

static void
case_fn_0261()
{
                node_proc       *       pProc;
                char            *       pName;
                SymTable        *       pParamSymTbl = pCurSymTbl;
                BOOL                    IsProc          = TRUE;

                /**
                 ** If the declarator was an ID and just a simple ID (basic type is
                 ** a null), we have just seen a declaration of a procedure.
                 ** If we saw an ID which had a basic type, then the ID is a declarator
                 ** whose basic type is a procedure (like in a typedef of a proc or
                 ** pointer to proc).
                 **/

                /**
                 ** if the node is a simple ID, then copy node details, else,
                 ** set the basic type of the declarator as this proc, and set the
                 ** procs name to a temporary.
                 **/

                // gaj - check for null...
                if ( ( yypvt[-3].yy_declarator.pHighest == yypvt[-3].yy_declarator.pLowest)
                        && (yypvt[-3].yy_declarator.pLowest->NodeKind() == NODE_ID ) )
                        {
                        pProc = new node_proc( ImportLevel,
                                                                   IS_CUR_INTERFACE_LOCAL(),
                                                                   (node_id_fe *) yypvt[-3].yy_declarator.pHighest);

                        pName   = pProc->GetSymName();

                        yyval.yy_declarator.pHighest = pProc;
                        yyval.yy_declarator.pLowest = pProc;

                        delete (node_id_fe *) yypvt[-3].yy_declarator.pHighest;

                        }
                else
                        {
                        pProc = new node_proc( ImportLevel,
                                                                   IS_CUR_INTERFACE_LOCAL() );
                        pProc->SetSymName( pName = GenTempName() );

                        yypvt[-3].yy_declarator.pLowest->SetChild( pProc );
                        yyval.yy_declarator.pHighest = yypvt[-3].yy_declarator.pHighest;

                        yyval.yy_declarator.pLowest = pProc;

                        IsProc = FALSE;
                        }


                /**
                 ** Set members of the procedure node as the parameter nodes.
                 **/

                pProc->SetMembers( yypvt[-1].yy_siblist );

                /**
                 ** discard the inner symbol table contents (unless it had fwds)
                 **/

                pCurSymTbl->DiscardScope();

                /**
                 ** restore the symbol tables scope to normal, since we have already
                 ** picked up a pointer to the next scope symbol table.
                 **/

                pSymTblMgr->PopSymLevel( &pCurSymTbl );


                /**
                 ** if this proc was entered into our symbol table, then this is a
                 ** redeclaration.But wait ! This is true only if the importlevel is 0
                 ** I.e , if there was a proc of the same name defined at an import
                 ** level greater, we dont care. (Actually, we must really check
                 ** signatures, so that valid redeclarations are ok, with a warning )
                 **/

                if( IsProc )
                        {
                        SymKey          SKey( pName , NAME_PROC );

                        //if ( ImportLevel == 0 )
                                {
                                if( !pInterfaceInfoDict->GetInterfaceProcTable()->
                                SymInsert( SKey, pParamSymTbl, pProc ) )
                            {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }
                                }
                    /********
                        else
                                CheckGlobalNamesClash( SKey );
                    ********/
                        }

                /**
                 ** finally, for the const support, if the optional const is true
                 ** apply the const attribute on the proc
                 **/

                pProc->SetModifiers( yypvt[-0].yy_modifiers );


                }

static void
case_fn_0262()
{

                /**
                 ** this is an abstract declarator for a procedure. Generate a
                 ** new proc node with a temp name, enter the name into the symbol
                 ** table.
                 **/

                char    *       pName = GenTempName();
                SymKey          SKey( pName, NAME_PROC );

                node_proc * pProc       = new node_proc( ImportLevel,
                                                                                         IS_CUR_INTERFACE_LOCAL() );
                yyval.yy_declarator.Init ( pProc );

                pProc->SetSymName( pName );

                /**
                 ** enter this into the symbol table , only if we are in the base idl
                 ** file, not an imported file.
                 **/

                if( ImportLevel == 0 )
                        pInterfaceInfoDict->GetInterfaceProcTable()->SymInsert( SKey,
                                                                        (SymTable *)NULL,
                                                                        (named_node *) yyval.yy_declarator.pHighest );

                /**
                 ** finally, for the const support, if the optional const is true
                 ** apply the const attribute on the proc
                 **/

                pProc->SetModifiers( yypvt[-0].yy_modifiers );

                }

static void
case_fn_0263()
{

                /**
                 ** The basic type of the declarator is the array
                 **/
                yyval.yy_declarator.pHighest = yypvt[-1].yy_declarator.pHighest;
                yypvt[-1].yy_declarator.pLowest->SetChild( yypvt[-0].yy_declarator.pHighest );
                yyval.yy_declarator.pLowest  = yypvt[-0].yy_declarator.pLowest;

                }

static void
case_fn_0264()
{
                yyval.yy_declarator = yypvt[-0].yy_declarator;
                }

static void
case_fn_0265()
{
                char    *       pName = yypvt[-0].yy_pSymName;
                if ( !pName )
                        pName = GenTempName();

                yyval.yy_declarator.Init( new node_id_fe( pName ) );
                }

static void
case_fn_0266()
{
                /**
                 ** This production ensures that a declarator can be the same name
                 ** as a typedef. The lexer will return all lexemes which are
                 ** typedefed as TYPENAMEs and we need to permit the user to specify
                 ** a declarator of the same name as the type name too! This conflict
                 ** arises only in the declarator productions, so this is an easy way
                 ** to support it.
                 **/
                yyval.yy_declarator.Init( new node_id_fe( yypvt[-0].yy_graph->GetCurrentSpelling() ) );
                }

static void
case_fn_0267()
{

                /**
                 ** this production corresponds to no params to a function.
                 **/


                /**
                 ** Return it as an empty list of parameters
                 **/

                yyval.yy_siblist.Init( NULL );

                }

static void
case_fn_0268()
{
                yyval.yy_siblist      = yypvt[-1].yy_siblist;
                }

static void
case_fn_0270()
{

                /**
                 ** This is meaningless in rpc, but we consume it and report an
                 ** error during semantics, if a proc using this param ever gets
                 ** remoted. We call this a param node with the name "...". And set its
                 ** basic type to an error node, so that a param is properly terminated.
                 ** The backend can emit a "..." for the name, so that this whole
                 ** thing is essentially transparent to it.
                 **/

                if ( 1 ) //ImportLevel == 0 ) <- change back when imported params not needed
                        {
                        node_param      *       pParam  = new node_param;

                        pParam->SetSymName( "..." );
                        pParam->SetChild( pErrorTypeNode );

                        yyval.yy_siblist      = yypvt[-3].yy_siblist;
                        yyval.yy_siblist.Add( pParam );
                        }

                }

static void
case_fn_0271()
{
                yyval.yy_siblist.Init( yypvt[-0].yy_graph );
                }

static void
case_fn_0272()
{
                if ( yypvt[-0].yy_graph && yypvt[-2].yy_siblist.NonNull() )
                        {
                        yyval.yy_siblist.Add( (named_node *) yypvt[-0].yy_graph );
                        }
                else
                        {
                        // tbd - error if later parameters are void
                        }
                }

static void
case_fn_0273()
{
                if (0) // ( ImportLevel > 0 )
                        {
                        if ( yypvt[-0].yy_declarator.pHighest->NodeKind() == NODE_ID )
                                delete (node_id_fe *) yypvt[-0].yy_declarator.pHighest;
                        yyval.yy_graph = NULL;
                        }
                else
                        {
                        node_param      *       pParam;
                        char            *       pName;
                        node_id_fe      *       pOriginal = NULL;

                        /**
                         ** Apply the declaration specifier to the declarator as a basic type
                         **/

                        yypvt[-0].yy_declarator.pLowest->SetChild( yypvt[-1].yy_declspec.pNode );

                        /**
                         ** apply any attributes specified to the declaration specifiers
                         **/

                        yypvt[-0].yy_declarator.pLowest->SetModifiers( yypvt[-1].yy_declspec.modifiers );

                        /**
                         ** if the declarator was just an id, then we have to copy the
                         ** node details over, else set the basic type of the param to
                         ** the declarator
                         **/

                        if ( yypvt[-0].yy_declarator.pHighest->NodeKind() == NODE_ID )
                                {
                                pOriginal = (node_id_fe *) yypvt[-0].yy_declarator.pHighest;
                                pParam = new node_param( pOriginal );
                                }
                        else
                                {
                                pParam = new node_param;
                                pParam->SetChild( yypvt[-0].yy_declarator.pHighest );
                                };

                        /**
                         ** prepare for symbol table entry.
                         **/

                        if( !(pName     = pParam->GetSymName()) )
                                {
                                pParam->SetSymName(pName = GenTempName() );
                                }

                        if ( IsTempName( pParam->GetSymName() ) )
                                ParseError( ABSTRACT_DECL, (char *)NULL );

                        SymKey  SKey( pName, NAME_MEMBER );

                        /**
                         ** enter the parameter into the symbol table.
                         ** If the user specified more than one param with the same name,
                         ** report an error, else insert the symbol into the table
                         **/

                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pParam ) )
                                {

                                //
                                // dont complain on another param of name void. This check is
                                // made elsewhere.
                                //

                                if( strcmp( pName, "void" ) != 0 )
                                        ParseError( DUPLICATE_DEFINITION, pName );
                                }
                        else
                                CheckGlobalNamesClash( SKey );

                        if ( yypvt[-2].yy_attrlist )
                                {
                                pParam->AddAttributes( yypvt[-2].yy_attrlist );
                                }

                        // clean up any old node_id

                        if ( pOriginal )
                                delete pOriginal;

                        /**
                         ** return the node back
                         **/

                        yyval.yy_graph      = pParam;

                        }
                }

static void
case_fn_0274()
{
                /**
                 ** This is the case when the user specified a simple abstract
                 ** declaration eg proc1( short ). In other words, the declarator is
                 ** optional. Abstract declarators are illegal in osf mode.
                 ** If the declaration specifier is a void then skip the parameter
                 **/

                if( // ( ImportLevel > 0 ) ||
                        ( yypvt[-0].yy_declspec.pNode->NodeKind() == NODE_VOID ) )
                        {
                        yyval.yy_graph = NULL;
                        }
                else
                        {

                        char            *       pName                   =   GenTempName();
                        SymKey                  SKey( pName, NAME_MEMBER );
                        node_param      *       pParam                  = new node_param;


                        pParam->SetSymName( pName );
                        pParam->SetChild( yypvt[-0].yy_declspec.pNode );

                        ParseError( ABSTRACT_DECL, (char *)NULL );

                        /**
                         ** enter into symbol table, just like anything else.
                         **/

                        if( !pCurSymTbl->SymInsert( SKey, (SymTable *)NULL, pParam ) )
                                {
                                ParseError( DUPLICATE_DEFINITION, pName );
                                }

                        /**
                         ** apply any attributes specified to the declaration specifiers
                         **/

                        pParam->SetModifiers( yypvt[-0].yy_declspec.modifiers );

                        if ( yypvt[-1].yy_attrlist )
                                {
                                pParam->AddAttributes( yypvt[-1].yy_attrlist );
                                }

                        yyval.yy_graph      = pParam;
                        }

                }

static void
case_fn_0275()
{
                yyval.yy_modifiers      = SetModifierBit(ATTR_PROC_CONST);
                }

static void
case_fn_0276()
{
                yyval.yy_modifiers      = 0;
                }

static void
case_fn_0277()
{
                yyval.yy_declarator.Init( new node_array( yypvt[-0].yy_abounds.LowerBound, yypvt[-0].yy_abounds.UpperBound ) );
                }

static void
case_fn_0278()
{
                /**
                 ** we identify a conformant array by setting the upperbound to -1
                 ** and the lower to 0
                 **/

                yyval.yy_abounds.UpperBound   = (expr_node *) -1;
                yyval.yy_abounds.LowerBound   = (expr_node *) 0;

                }

static void
case_fn_0279()
{

                /**
                 ** This is also taken to mean a conformant array, upper bound known
                 ** only at runtime. The lower bound is 0
                 **/

                yyval.yy_abounds.UpperBound   = (expr_node *)-1;
                yyval.yy_abounds.LowerBound   = (expr_node *)0;
                }

static void
case_fn_0280()
{

                /**
                 ** this is the case of an array whose lower bound is 0
                 **/

                yyval.yy_abounds.UpperBound   = yypvt[-1].yy_expr;
                yyval.yy_abounds.LowerBound   = (expr_node *)0;

                }

static void
case_fn_0281()
{
                if( (yypvt[-1].yy_abounds.LowerBound)->Evaluate() != 0 )
                        ParseError( ARRAY_BOUNDS_CONSTRUCT_BAD, (char *)NULL );
                yyval.yy_abounds      = yypvt[-1].yy_abounds;
                }

static void
case_fn_0282()
{
                /**
                 ** the fact that the expected expression is not a constant is
                 ** verified by the constantExpr production. All we have to do here is
                 ** to pass the expression up.
                 **/

                yyval.yy_abounds.LowerBound   = yypvt[-2].yy_expr;
                yyval.yy_abounds.UpperBound   = new expr_b_arithmetic( OP_PLUS,
                                                                                        yypvt[-0].yy_expr,
                                                                                        GetConstant1() );

                }

static void
case_fn_0283()
{
                yyval.yy_short      = KWISOLATIN1;
                }

static void
case_fn_0284()
{
                yyval.yy_short      = KWPRIVATECHAR8;
                }

static void
case_fn_0285()
{
                yyval.yy_short      = KWISOMULTILINGUAL;
                }

static void
case_fn_0286()
{
                yyval.yy_short      = KWPRIVATECHAR16;
                }

static void
case_fn_0287()
{
                yyval.yy_short      = KWISOUCS;
                }

static void
case_fn_0289()
{
                yyval.yy_attrlist.MakeAttrList();
                }

static void
case_fn_0291()
{
                yyval.yy_attrlist.MakeAttrList();
                }

static void
case_fn_0292()
{
                // note that in all left-recursive productions like this we are
                // relying on an implicit yyval.yy_attrlist = yypvt[-1].yy_attrlist operation
                yyval.yy_attrlist.Merge( yypvt[-0].yy_attrlist );
                }

static void
case_fn_0294()
{
                // note that in all left-recursive productions like this we are
                // relying on an implicit yyval.yy_attrlist = yypvt[-1].yy_attrlist operation
                yyval.yy_attrlist.Merge( yypvt[-0].yy_attrlist );
                }

static void
case_fn_0296()
{
                yyval.yy_attrlist      = yypvt[-1].yy_attrlist;
                }

static void
case_fn_0297()
{
                yyval.yy_attrlist      = yypvt[-1].yy_attrlist;
                }

static void
case_fn_0298()
{
                yyval.yy_attrlist.Merge( yypvt[-0].yy_attrlist );
                }

static void
case_fn_0300()
{
                yyval.yy_attrlist.Merge( yypvt[-0].yy_attrlist );
                }

static void
case_fn_0302()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0303()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0305()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0306()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0307()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0308()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0309()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0310()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0312()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0313()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0314()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0315()
{
                yyval.yy_attrlist.MakeAttrList( yypvt[-0].yy_attr );
                }

static void
case_fn_0316()
{
                yyval.yy_attrlist.MakeAttrList(new battr( ATTR_DEFAULT ));
                }

static void
case_fn_0317()
{
                yyval.yy_attr      = yypvt[-1].yy_attr;
                }

static void
case_fn_0318()
{
                LexContext = LEX_GUID;  /* turned off by the lexer */
                }

static void
case_fn_0319()
{
                yyval.yy_attr      = yypvt[-1].yy_attr;
                }

static void
case_fn_0320()
{
                yyval.yy_attr      = new battr( ATTR_LOCAL );
                }

static void
case_fn_0321()
{
                ParseError( INVALID_OSF_ATTRIBUTE, "[object]" );
                yyval.yy_attr      = new battr( ATTR_OBJECT );
                }

static void
case_fn_0322()
{
                LexContext = LEX_VERSION;
                /* LexContext is reset by lexer */
                }

static void
case_fn_0323()
{
                yyval.yy_attr      = (new node_version( yypvt[-1].yy_string ));
                }

static void
case_fn_0324()
{
                yyval.yy_attr      = yypvt[-1].yy_attr;
                }

static void
case_fn_0325()
{
                if( !pCommand->IsSwitchDefined( SWITCH_APP_CONFIG ) )
                        {
                        ParseError( ACF_IN_IDL_NEEDS_APP_CONFIG,
                                                (yypvt[-0].yy_attr)->GetNodeNameString() );
                        }
                yyval.yy_attr = yypvt[-0].yy_attr;
                }

static void
case_fn_0326()
{
                yyval.yy_attr = NULL;
                }

static void
case_fn_0327()
{
                yyval.yy_attr      = (new node_guid( yypvt[-0].yy_string ));
                }

static void
case_fn_0328()
{
                yyval.yy_attr = new node_endpoint( yypvt[-0].yy_string );
                }

static void
case_fn_0329()
{
                yyval.yy_attr = yypvt[-2].yy_attr;
                ( (node_endpoint *) yyval.yy_attr)->SetEndPointString( yypvt[-0].yy_string );
                }

static void
case_fn_0331()
{
                yyval.yy_attr      = (new node_implicit( yypvt[-2].yy_graph, new node_id_fe(yypvt[-1].yy_pSymName) ));
                }

static void
case_fn_0332()
{
                yyval.yy_attr      = (new acf_attr( ATTR_AUTO ));
                }

static void
case_fn_0333()
{
                GetBaseTypeNode( &(yyval.yy_graph), SIGN_UNDEF, SIZE_UNDEF, TYPE_HANDLE_T );
                }

static void
case_fn_0334()
{
                node_forward    *       pFwd;

                SymKey  SKey( yypvt[-0].yy_pSymName, NAME_DEF );
                pFwd    = new node_forward( SKey, pCurSymTbl );
                pFwd->SetSymName( yypvt[-0].yy_pSymName );

                pFwd->SetAttribute( ATTR_HANDLE );
                yyval.yy_graph = pFwd;

                //
                // keep a track of this node to ensure it is not used as a
                // context handle.
                //

                if( ImportLevel == 0 )
                        {
                        pBaseImplicitHandle = yyval.yy_graph;
                        }
                }

static void
case_fn_0336()
{
                yyval.yy_attr = NULL;
                }

static void
case_fn_0337()
{
                yyval.yy_attr      = new battr( ATTR_HANDLE );
                }

static void
case_fn_0338()
{
                yyval.yy_attr      = (new battr( ATTR_STRING ));
                }

static void
case_fn_0339()
{
                yyval.yy_attr      = (new battr( ATTR_BSTRING ));
                }

static void
case_fn_0340()
{
                yyval.yy_attr      = (new battr( ATTR_CONTEXT ));
                }

static void
case_fn_0341()
{
                yyval.yy_attr      = (new node_switch_type( yypvt[-1].yy_graph ));
                }

static void
case_fn_0342()
{
                yyval.yy_attr      = (new node_transmit( yypvt[-1].yy_graph ));
                }

static void
case_fn_0343()
{
                yyval.yy_attr      = (new node_wire_marshal( yypvt[-1].yy_graph ));
                }

static void
case_fn_0344()
{
                yyval.yy_attr = yypvt[-1].yy_attr;
                }

static void
case_fn_0345()
{
                yyval.yy_attr      = new battr( ATTR_MS_UNION );
                }

static void
case_fn_0346()
{
                yyval.yy_attr      = new battr( ATTR_OPAQUE );
                }

static void
case_fn_0347()
{
                yyval.yy_attr      = new battr( ATTR_V1_ENUM );
                }

static void
case_fn_0348()
{
                SymKey                  SKey( yypvt[-0].yy_pSymName, NAME_PROC );
                node_proc   *   pProc   = (node_proc *)
                        pInterfaceInfoDict->GetInterfaceProcTable()->SymSearch( SKey );


                yyval.yy_attr = new node_call_as( yypvt[-0].yy_pSymName, pProc );
                }

static void
case_fn_0349()
{
                ParseError(IGNORE_UNIMPLEMENTED_ATTRIBUTE, "[align]");
                }

static void
case_fn_0350()
{
                ParseError(IGNORE_UNIMPLEMENTED_ATTRIBUTE, "[unaligned]");
                }

static void
case_fn_0351()
{
                ParseError(IGNORE_UNIMPLEMENTED_ATTRIBUTE, "[v1_array]");
                }

static void
case_fn_0352()
{
                ParseError(IGNORE_UNIMPLEMENTED_ATTRIBUTE, "[v1_string]");
                }

static void
case_fn_0353()
{
                ParseError(IGNORE_UNIMPLEMENTED_ATTRIBUTE, "[v1_struct]");
                }

static void
case_fn_0354()
{
                yyval.yy_attr = new node_ptr_attr( PTR_REF );
                }

static void
case_fn_0355()
{
                yyval.yy_attr = new node_ptr_attr( PTR_UNIQUE );
                }

static void
case_fn_0356()
{
                yyval.yy_attr = new node_ptr_attr( PTR_FULL );
                }

static void
case_fn_0357()
{
                yyval.yy_attr = new battr( ATTR_IGNORE );
                }

static void
case_fn_0358()
{
                if( yypvt[-0].yy_type.BaseType == TYPE_UNDEF )
                        yypvt[-0].yy_type.BaseType     = TYPE_INT;
                if( yypvt[-0].yy_type.TypeSign == SIGN_UNDEF )
                        yypvt[-0].yy_type.TypeSign = SIGN_SIGNED;
                GetBaseTypeNode( &(yyval.yy_graph), yypvt[-0].yy_type.TypeSign, yypvt[-0].yy_type.TypeSize, yypvt[-0].yy_type.BaseType );
                }

static void
case_fn_0359()
{
                GetBaseTypeNode( &(yyval.yy_graph), yypvt[-0].yy_type.TypeSign, SIZE_CHAR, TYPE_INT );
                }

static void
case_fn_0360()
{
                GetBaseTypeNode( &(yyval.yy_graph), SIGN_UNDEF, SIZE_UNDEF, TYPE_BYTE );
                }

static void
case_fn_0361()
{
                GetBaseTypeNode( &(yyval.yy_graph), SIGN_UNDEF, SIZE_UNDEF, TYPE_BOOLEAN );
                }

static void
case_fn_0362()
{
                SymKey  SKey( yypvt[-0].yy_string, NAME_ENUM );

                if( ! (yyval.yy_graph = pBaseSymTbl->SymSearch( SKey ) ) )
                        {
                        ParseError( UNDEFINED_SYMBOL, yypvt[-0].yy_string );
                        yyval.yy_graph      = new node_error;
                        }
                }

static void
case_fn_0364()
{
                yyval.yy_attrlist      = (GenerateFieldAttribute( ATTR_FIRST, yypvt[-1].yy_exprlist ));
                }

static void
case_fn_0365()
{
                yyval.yy_attrlist      = (GenerateFieldAttribute( ATTR_LAST, yypvt[-1].yy_exprlist ));
                }

static void
case_fn_0366()
{
                yyval.yy_attrlist      = (GenerateFieldAttribute( ATTR_LENGTH, yypvt[-1].yy_exprlist ));
                }

static void
case_fn_0367()
{
                yyval.yy_attrlist      = (GenerateFieldAttribute( ATTR_MIN, yypvt[-1].yy_exprlist ));
                }

static void
case_fn_0368()
{
                yyval.yy_attrlist      = (GenerateFieldAttribute( ATTR_MAX, yypvt[-1].yy_exprlist ));
                }

static void
case_fn_0369()
{
                yyval.yy_attrlist      = (GenerateFieldAttribute( ATTR_SIZE, yypvt[-1].yy_exprlist ));
                }

static void
case_fn_0370()
{
                yyval.yy_attrlist.MakeAttrList( new node_switch_is( yypvt[-1].yy_expr ));
                }

static void
case_fn_0371()
{
                ParseError( INVALID_OSF_ATTRIBUTE, "[iid_is()]" );
                yyval.yy_attrlist.MakeAttrList( new size_attr( yypvt[-1].yy_expr, ATTR_IID_IS ));
                }

static void
case_fn_0372()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_ID));
                }

static void
case_fn_0373()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_HELPCONTEXT ));
                }

static void
case_fn_0374()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[helpstringcontext()]");
                    }
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_HELPSTRINGCONTEXT ));
                }

static void
case_fn_0375()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_LCID ));
                }

static void
case_fn_0376()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_FUNCDESCATTR ));
                }

static void
case_fn_0377()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_IDLDESCATTR ));
                }

static void
case_fn_0378()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_TYPEDESCATTR ));
                }

static void
case_fn_0379()
{
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_VARDESCATTR ));
                }

static void
case_fn_0380()
{
                yyval.yy_attrlist.MakeAttrList( new node_text_attr( yypvt[-1].yy_string, ATTR_DLLNAME ));
                }

static void
case_fn_0381()
{
                TranslateEscapeSequences(yypvt[-1].yy_string);
                yyval.yy_attrlist.MakeAttrList( new node_text_attr( yypvt[-1].yy_string, ATTR_HELPSTRING ));
                }

static void
case_fn_0382()
{
                TranslateEscapeSequences(yypvt[-1].yy_string);
                yyval.yy_attrlist.MakeAttrList( new node_text_attr( yypvt[-1].yy_string, ATTR_HELPFILE ));
                }

static void
case_fn_0383()
{
                    yyval.yy_attrlist.MakeAttrList( new node_entry_attr( yypvt[-1].yy_string ));
                }

static void
case_fn_0384()
{
                    yyval.yy_attrlist.MakeAttrList( new node_entry_attr( (long) yypvt[-1].yy_numeric.Val ));
                }

static void
case_fn_0385()
{
                    yyval.yy_attrlist.MakeAttrList( new node_entry_attr( (long) yypvt[-1].yy_numeric.Val ));
                }

static void
case_fn_0386()
{
                    yyval.yy_attrlist.MakeAttrList( new node_entry_attr( (long) yypvt[-1].yy_numeric.Val ));
                }

static void
case_fn_0387()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[defaultvalue()]");
                    }
                yyval.yy_attrlist.MakeAttrList( new node_constant_attr( yypvt[-1].yy_expr, ATTR_DEFAULTVALUE ));
                }

static void
case_fn_0388()
{
                LexContext = LEX_GUID;  /* turned off by the lexer */
                }

static void
case_fn_0389()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[custom()]");
                    }
                yyval.yy_attrlist.MakeAttrList( new node_custom_attr( (node_guid *)yypvt[-3].yy_attr, yypvt[-1].yy_expr ));
                }

static void
case_fn_0390()
{
                yyval.yy_exprlist->SetPeer( yypvt[-0].yy_expr );
                }

static void
case_fn_0391()
{
                yyval.yy_exprlist      = new expr_list;
                yyval.yy_exprlist->SetPeer( yypvt[-0].yy_expr );
                }

static void
case_fn_0393()
{
            yyval.yy_expr = NULL;
            }

static void
case_fn_0394()
{
                yyval.yy_attr      = new battr ( ATTR_IN );
                /*****************
                if( $2 )
                        $$.Merge( ATTRLIST Shape_Attr($2) );
                ******************/
                }

static void
case_fn_0395()
{
                yyval.yy_attr      = new battr ( ATTR_OUT );
                /*****************
                if( $2 )
                        $$.Merge( ATTRLIST Shape_Attr($2) );
                ******************/
                }

static void
case_fn_0396()
{
                yyval.yy_attr      = (new battr( ATTR_CALLBACK ));
                }

static void
case_fn_0397()
{
                yyval.yy_attr      = (new battr( ATTR_IDEMPOTENT ));
                }

static void
case_fn_0398()
{
                yyval.yy_attr      = (new battr( ATTR_BROADCAST ));
                }

static void
case_fn_0399()
{
                yyval.yy_attr      = (new battr( ATTR_MAYBE ));
                }

static void
case_fn_0400()
{
                yyval.yy_attr      = (new battr( ATTR_ASYNC ));
                }

static void
case_fn_0401()
{
                yyval.yy_attr      = (new battr( ATTR_INPUTSYNC ));
                }

static void
case_fn_0402()
{
                yyval.yy_attr      = (new battr( ATTR_HIDDEN ));
                }

static void
case_fn_0403()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_PROPGET ));
                }

static void
case_fn_0404()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_PROPPUT ));
                }

static void
case_fn_0405()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_PROPPUTREF ));
                }

static void
case_fn_0406()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_OPTIONAL ));
                }

static void
case_fn_0407()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_VARARG ));
                }

static void
case_fn_0408()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_RESTRICTED ));
                }

static void
case_fn_0409()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_READONLY ));
                }

static void
case_fn_0410()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_SOURCE ));
                }

static void
case_fn_0411()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[defaultvtable]");
                    }
                yyval.yy_attr      = (new node_member_attr( MATTR_DEFAULTVTABLE ));
                }

static void
case_fn_0412()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[immediatebind]");
                    }
                yyval.yy_attr      = (new node_member_attr( MATTR_IMMEDIATEBIND ));
                }

static void
case_fn_0413()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[replaceable]");
                    }
                yyval.yy_attr      = (new node_member_attr( MATTR_REPLACEABLE ));
                }

static void
case_fn_0414()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_USESGETLASTERROR ));
                }

static void
case_fn_0415()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_BINDABLE ));
                }

static void
case_fn_0416()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_REQUESTEDIT ));
                }

static void
case_fn_0417()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_DISPLAYBIND ));
                }

static void
case_fn_0418()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_DEFAULTBIND ));
                }

static void
case_fn_0419()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_PREDECLID ));
                }

static void
case_fn_0420()
{
                yyval.yy_attr      = (new node_member_attr( MATTR_RETVAL ));
                }

static void
case_fn_0421()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_APPOBJECT ));
                }

static void
case_fn_0422()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_PUBLIC ));
                }

static void
case_fn_0423()
{
                yyval.yy_attr      = NULL;
                }

static void
case_fn_0424()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_LICENSED ));
                }

static void
case_fn_0425()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_CONTROL ));
                }

static void
case_fn_0426()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_DUAL ));
                }

static void
case_fn_0427()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_NONEXTENSIBLE ));
                }

static void
case_fn_0428()
{
                yyval.yy_attr      = (new node_type_attr( TATTR_OLEAUTOMATION ));
                }

static void
case_fn_0429()
{
                yyval.yy_attr      = (new battr( ATTR_FLCID ));    
                }

static void
case_fn_0430()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[noncreatable]");
                    }
                yyval.yy_attr      = (new node_type_attr( TATTR_NONCREATABLE ));
                }

static void
case_fn_0431()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[aggregatable]");
                    }
                yyval.yy_attr      = (new node_type_attr( TATTR_AGGREGATABLE ));
                }

static void
case_fn_0432()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[uidefault]");
                    }
                yyval.yy_attr      = (new node_member_attr( MATTR_UIDEFAULT ));
                }

static void
case_fn_0433()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[nonbrowsable]");
                    }
                yyval.yy_attr      = (new node_member_attr( MATTR_NONBROWSABLE ));
                }

static void
case_fn_0434()
{
                if (!FNewTypeLib())
                    {
                    ParseError( INVALID_NEWTLB_ATTRIBUTE, "[defaultcollem]");
                    }
                yyval.yy_attr      = (new node_member_attr( MATTR_DEFAULTCOLLELEM ));
                }

static void
case_fn_0435()
{
                ParseError(IGNORE_UNIMPLEMENTED_ATTRIBUTE, "[shape]");
                yyval.yy_attrenum      = ATTR_NONE;
                }

static void
case_fn_0436()
{
                yyval.yy_attrenum      = ATTR_NONE;
                }

static void
case_fn_0437()
{
                yyval.yy_expr      = yypvt[-0].yy_expr;
#ifdef gajdebug3
                printf("\t...init list has constant=%d, from %d\n",
                                                yyval.yy_expr->IsConstant(),yypvt[-0].yy_expr->IsConstant() );
#endif
                }

static void
case_fn_0438()
{
                ParseError( COMPOUND_INITS_NOT_SUPPORTED, (char *)0 );
                yyval.yy_expr = NULL;
//              yyval.yy_expr      = new expr_init_list( (expr_node *)NULL );
//              yyval.yy_expr->LinkChild( yypvt[-2].yy_initlist );
                }

static void
case_fn_0441()
{
//              yyval.yy_initlist      = yypvt[-0].yy_expr;
                }

static void
case_fn_0442()
{
//              yyval.yy_initlist->LinkSibling( yypvt[-0].yy_expr );
                }

static void
case_fn_0444()
{
                yyval.yy_expr      = yypvt[-0].yy_expr;
                }

static void
case_fn_0446()
{

                /**
                 ** The expression must be a constant, if not report error
                 **/

#ifdef gajdebug3
                printf("constant expr is: %d\n",yypvt[-0].yy_expr->IsConstant());
#endif
                if( ! yypvt[-0].yy_expr->IsConstant() )
                        ParseError( EXPR_NOT_CONSTANT, (char *)NULL );
                yyval.yy_expr      = yypvt[-0].yy_expr;

                }

static void
case_fn_0448()
{

                /**
                 ** we do not permit assignment in expressions
                 **/

                ParseError( SYNTAX_ERROR, (char *)NULL );
                yyval.yy_expr      = new expr_error;

                }

static void
case_fn_0449()
{

                yyval.yy_expr = yypvt[-0].yy_expr;
#if 0

printf("\n************** expression dump start ***************\n");
BufferManager   *       pOutput = new BufferManager( 10 );
yyval.yy_expr->PrintExpr( (BufferManager *)NULL, (BufferManager *)NULL, pOutput );
pOutput->Print( stdout );
printf("\n****************************************************\n");

#endif // 0
                }

static void
case_fn_0450()
{

                /**
                 ** This is a ternary operator.
                 **/

                yyval.yy_expr      = new expr_ternary( OP_QM, yypvt[-4].yy_expr, yypvt[-2].yy_expr, yypvt[-0].yy_expr );

                }

static void
case_fn_0452()
{
                yyval.yy_expr      = new expr_b_logical( OP_LOGICAL_OR, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0454()
{
                yyval.yy_expr      = new expr_b_logical( OP_LOGICAL_AND, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0456()
{
                yyval.yy_expr      = new expr_bitwise( OP_OR, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0458()
{
                yyval.yy_expr      = new expr_bitwise( OP_XOR, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0460()
{
                yyval.yy_expr      = new expr_bitwise( OP_AND, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0462()
{
                yyval.yy_expr      = new expr_relational( OP_EQUAL, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0463()
{
                yyval.yy_expr      = new expr_relational( OP_NOT_EQUAL, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0465()
{
                yyval.yy_expr      = new expr_relational( OP_LESS, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0466()
{
                yyval.yy_expr      = new expr_relational( OP_GREATER, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0467()
{
                yyval.yy_expr      = new expr_relational( OP_LESS_EQUAL, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0468()
{
                yyval.yy_expr      = new expr_relational( OP_GREATER_EQUAL, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0470()
{
                yyval.yy_expr      = new expr_shift( OP_LEFT_SHIFT, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0471()
{
                yyval.yy_expr      = new expr_shift( OP_RIGHT_SHIFT, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0473()
{
                yyval.yy_expr      = new expr_b_arithmetic( yypvt[-1].yy_operator, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0475()
{
                yyval.yy_expr      = new expr_b_arithmetic( yypvt[-1].yy_operator, yypvt[-2].yy_expr, yypvt[-0].yy_expr );
                }

static void
case_fn_0477()
{
                node_skl        *       pNode   = pErrorTypeNode;

                if( yypvt[-3].yy_declspec.pNode )
                        {

                        if( yypvt[-2].yy_declarator.pHighest )
                                {
                                yypvt[-2].yy_declarator.pLowest->SetChild( yypvt[-3].yy_declspec.pNode );
                                pNode   = yypvt[-2].yy_declarator.pHighest;
                                if( yypvt[-3].yy_declspec.modifiers )
                                        {
                                        ( (named_node *) yypvt[-2].yy_declarator.pLowest)->SetModifiers( yypvt[-3].yy_declspec.modifiers );
                                        }
                                }
                        else
                                pNode   = yypvt[-3].yy_declspec.pNode;

                        }
                yyval.yy_expr      = new expr_cast( pNode, yypvt[-0].yy_expr );
                }

static void
case_fn_0479()
{
                ( (expr_op_unary *) (yyval.yy_expr = yypvt[-1].yy_expr) )->SetLeft( yypvt[-0].yy_expr );
                if ( yypvt[-0].yy_expr )
                        ( (expr_op_unary *) yyval.yy_expr)->SetConstant( yypvt[-0].yy_expr->IsConstant() );
                }

static void
case_fn_0480()
{

                /**
                 ** The sizeof construct looks like a declaration and a possible
                 ** declarator. All we really do, is to contruct the type ( graph )
                 ** and hand it over to the sizeof expression node. If there was an
                 ** error, just construct the size of with an error node
                 **/

                node_skl        *       pNode   = pErrorTypeNode;
                node_skl        *       pLow;

                if( yypvt[-2].yy_declspec.pNode )
                        {

                        if( yypvt[-1].yy_declarator.pHighest )
                                {
                                pNode   = yypvt[-1].yy_declarator.pHighest;
                                pLow    = yypvt[-1].yy_declarator.pLowest;
                                pLow->SetChild( yypvt[-2].yy_declspec.pNode );
                                pLow->SetModifiers( yypvt[-2].yy_declspec.modifiers );
                                }
                        else
                                {
                                pNode   = yypvt[-2].yy_declspec.pNode;
                                }

                        }

                yyval.yy_expr      = new expr_sizeof( pNode );
                }

static void
case_fn_0481()
{
                yyval.yy_expr = new expr_sizeof( yypvt[-0].yy_expr );
                }

static void
case_fn_0483()
{
                yyval.yy_expr      = new expr_index( yypvt[-3].yy_expr, yypvt[-1].yy_expr );
                }

static void
case_fn_0484()
{

                /**
                 ** not implemented
                 **/

                ParseError( EXPR_NOT_IMPLEMENTED, (char *)NULL );
                yyval.yy_expr      = new expr_error;

                }

static void
case_fn_0485()
{

                expr_variable   *       pIDExpr = new expr_variable( yypvt[-0].yy_pSymName );
                yyval.yy_expr      = new expr_pointsto( yypvt[-2].yy_expr, pIDExpr );

                }

static void
case_fn_0486()
{

                expr_variable   *       pIDExpr = new expr_variable( yypvt[-0].yy_pSymName );
                yyval.yy_expr      = new expr_dot( yypvt[-2].yy_expr, pIDExpr );

                }

static void
case_fn_0487()
{
                // true if the identifier represents a constant
                BOOL                    ConstVar        = FALSE;
                named_node      *       pNode           = NULL;
                SymKey                  SKey( yypvt[-0].yy_pSymName, NAME_MEMBER );

                pNode = pCurSymTbl->SymSearch( SKey );

                // look for a global ID matching the id
                if ( ! pNode )
                        {
                        SymKey  SKey2( yypvt[-0].yy_pSymName, NAME_ID );
                        pNode = pBaseSymTbl->SymSearch( SKey2 );
                        ConstVar = (pNode) ? ((node_id_fe *) pNode)->IsConstant() : FALSE;
                        }

                // look for a global enum label matching the id
                if ( !pNode )
                        {
                        SymKey  SKey2( yypvt[-0].yy_pSymName, NAME_LABEL );
                        pNode = pBaseSymTbl->SymSearch( SKey2 );
                        ConstVar = (pNode != NULL);
                        }

                if ( !pNode ) pNode     = new node_forward( SKey, pCurSymTbl );

                if (ConstVar)
                        {
                        yyval.yy_expr = new expr_named_constant( yypvt[-0].yy_pSymName, pNode );
                        }
                else
                        {
                        yyval.yy_expr      = new expr_variable( yypvt[-0].yy_pSymName, pNode );
                        }
                }

static void
case_fn_0488()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_NUMERIC );
                }

static void
case_fn_0489()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_NUMERIC_U);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_UNSIGNED,SIZE_UNDEF,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0490()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_NUMERIC_LONG);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_SIGNED,SIZE_LONG,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0491()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_NUMERIC_ULONG);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_UNSIGNED,SIZE_LONG,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0492()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_HEX );
                }

static void
case_fn_0493()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_HEX_U);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_UNSIGNED,SIZE_UNDEF,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0494()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_HEX_LONG);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_SIGNED,SIZE_LONG,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0495()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_HEX_ULONG);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_UNSIGNED,SIZE_LONG,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0496()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_OCTAL );
                }

static void
case_fn_0497()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_OCTAL_U);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_UNSIGNED,SIZE_UNDEF,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0498()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_OCTAL_LONG);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_SIGNED,SIZE_LONG,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0499()
{
                yyval.yy_expr      = new expr_constant( (long) yypvt[-0].yy_numeric.Val, VALUE_TYPE_OCTAL_ULONG);

                node_skl *      pType;
                GetBaseTypeNode( &pType, SIGN_UNSIGNED,SIZE_LONG,TYPE_INT );
                yyval.yy_expr->SetType( pType );
                }

static void
case_fn_0500()
{
                yyval.yy_expr      = new expr_constant( (long)TRUE, VALUE_TYPE_BOOL );
                }

static void
case_fn_0501()
{
                yyval.yy_expr      = new expr_constant( (long)FALSE, VALUE_TYPE_BOOL );
                }

static void
case_fn_0502()
{
                yyval.yy_expr      = new expr_constant( (char *)NULL, VALUE_TYPE_STRING );
                }

static void
case_fn_0503()
{
                yyval.yy_expr      = new expr_constant( (char *)yypvt[-0].yy_string, VALUE_TYPE_STRING );
                }

static void
case_fn_0504()
{
                ParseError( WCHAR_STRING_NOT_OSF, (char *)NULL );
                yyval.yy_expr      = new expr_constant( (wchar_t *)yypvt[-0].yy_string, VALUE_TYPE_WSTRING );
                }

static void
case_fn_0505()
{
                yyval.yy_expr = new expr_constant( (long)( ((long)yypvt[-0].yy_numeric.Val) & 0xff ) ,
                                VALUE_TYPE_CHAR );
                }

static void
case_fn_0506()
{
                yyval.yy_expr = new expr_constant( (long)( ((long)yypvt[-0].yy_numeric.Val ) & 0xffff ),
                                VALUE_TYPE_WCHAR );
                ParseError( WCHAR_CONSTANT_NOT_OSF, (char *)NULL );
                }

static void
case_fn_0507()
{
                yyval.yy_expr      = yypvt[-1].yy_expr;
                }

static void
case_fn_0508()
{
                yyval.yy_expr      = new expr_u_arithmetic( (yypvt[-0].yy_operator == OP_PLUS) ?
                                                                                        OP_UNARY_PLUS : OP_UNARY_MINUS,
                                                                         NULL );
                }

static void
case_fn_0509()
{
                yyval.yy_expr      = new expr_u_not( NULL );
                }

static void
case_fn_0510()
{
                yyval.yy_expr      = new expr_u_deref( OP_UNARY_AND, NULL );
                }

static void
case_fn_0511()
{
                yyval.yy_expr      = new expr_u_deref( OP_UNARY_INDIRECTION, NULL );
                }

static void
case_fn_0512()
{
                yyval.yy_expr      = new expr_u_complement( NULL);
                }

static void
case_fn_0513()
{
                yyval.yy_operator      = OP_PLUS;
                }

static void
case_fn_0514()
{
                yyval.yy_operator      = OP_MINUS;
                }

static void
case_fn_0515()
{
                yyval.yy_operator      = OP_STAR;
                }

static void
case_fn_0516()
{
                yyval.yy_operator      = OP_SLASH;
                }

static void
case_fn_0517()
{
                yyval.yy_operator      = OP_MOD;
                }

static void
case_fn_0518()
{
                ParseError( EXPR_NOT_IMPLEMENTED, (char *)NULL );
                yyval.yy_expr      = new expr_error;
                }

static void
case_fn_0519()
{
                                                        /* UNIMPLEMENTED YET */
                yyval.yy_expr      = yypvt[-2].yy_expr;
                }
static void
case_fn_0000() {
	}

static void	 (*case_fn_array[])() = 
	{
	 case_fn_0000
	,case_fn_0001
	,case_fn_0002
	,case_fn_0003
	,case_fn_0004
	,case_fn_0005
	,case_fn_0000
	,case_fn_0007
	,case_fn_0008
	,case_fn_0009
	,case_fn_0010
	,case_fn_0011
	,case_fn_0012
	,case_fn_0013
	,case_fn_0014
	,case_fn_0015
	,case_fn_0016
	,case_fn_0017
	,case_fn_0018
	,case_fn_0019
	,case_fn_0020
	,case_fn_0021
	,case_fn_0022
	,case_fn_0000
	,case_fn_0000
	,case_fn_0025
	,case_fn_0026
	,case_fn_0000
	,case_fn_0028
	,case_fn_0029
	,case_fn_0000
	,case_fn_0031
	,case_fn_0032
	,case_fn_0000
	,case_fn_0034
	,case_fn_0035
	,case_fn_0036
	,case_fn_0037
	,case_fn_0000
	,case_fn_0039
	,case_fn_0040
	,case_fn_0000
	,case_fn_0000
	,case_fn_0043
	,case_fn_0044
	,case_fn_0000
	,case_fn_0046
	,case_fn_0047
	,case_fn_0048
	,case_fn_0000
	,case_fn_0050
	,case_fn_0051
	,case_fn_0052
	,case_fn_0053
	,case_fn_0054
	,case_fn_0055
	,case_fn_0056
	,case_fn_0057
	,case_fn_0058
	,case_fn_0059
	,case_fn_0060
	,case_fn_0061
	,case_fn_0062
	,case_fn_0063
	,case_fn_0064
	,case_fn_0000
	,case_fn_0066
	,case_fn_0067
	,case_fn_0068
	,case_fn_0069
	,case_fn_0070
	,case_fn_0071
	,case_fn_0000
	,case_fn_0073
	,case_fn_0074
	,case_fn_0000
	,case_fn_0076
	,case_fn_0077
	,case_fn_0078
	,case_fn_0000
	,case_fn_0080
	,case_fn_0081
	,case_fn_0082
	,case_fn_0083
	,case_fn_0084
	,case_fn_0085
	,case_fn_0000
	,case_fn_0087
	,case_fn_0088
	,case_fn_0089
	,case_fn_0000
	,case_fn_0091
	,case_fn_0092
	,case_fn_0093
	,case_fn_0094
	,case_fn_0095
	,case_fn_0096
	,case_fn_0097
	,case_fn_0098
	,case_fn_0099
	,case_fn_0100
	,case_fn_0101
	,case_fn_0102
	,case_fn_0103
	,case_fn_0104
	,case_fn_0105
	,case_fn_0000
	,case_fn_0107
	,case_fn_0108
	,case_fn_0000
	,case_fn_0000
	,case_fn_0111
	,case_fn_0000
	,case_fn_0113
	,case_fn_0114
	,case_fn_0000
	,case_fn_0000
	,case_fn_0117
	,case_fn_0118
	,case_fn_0119
	,case_fn_0120
	,case_fn_0121
	,case_fn_0122
	,case_fn_0000
	,case_fn_0000
	,case_fn_0125
	,case_fn_0126
	,case_fn_0127
	,case_fn_0128
	,case_fn_0129
	,case_fn_0000
	,case_fn_0000
	,case_fn_0000
	,case_fn_0133
	,case_fn_0134
	,case_fn_0135
	,case_fn_0136
	,case_fn_0137
	,case_fn_0138
	,case_fn_0139
	,case_fn_0140
	,case_fn_0141
	,case_fn_0142
	,case_fn_0143
	,case_fn_0144
	,case_fn_0145
	,case_fn_0146
	,case_fn_0147
	,case_fn_0148
	,case_fn_0149
	,case_fn_0150
	,case_fn_0151
	,case_fn_0000
	,case_fn_0153
	,case_fn_0154
	,case_fn_0155
	,case_fn_0000
	,case_fn_0157
	,case_fn_0158
	,case_fn_0159
	,case_fn_0160
	,case_fn_0161
	,case_fn_0162
	,case_fn_0163
	,case_fn_0164
	,case_fn_0165
	,case_fn_0166
	,case_fn_0167
	,case_fn_0000
	,case_fn_0000
	,case_fn_0170
	,case_fn_0171
	,case_fn_0000
	,case_fn_0173
	,case_fn_0174
	,case_fn_0175
	,case_fn_0176
	,case_fn_0000
	,case_fn_0178
	,case_fn_0179
	,case_fn_0180
	,case_fn_0181
	,case_fn_0000
	,case_fn_0183
	,case_fn_0000
	,case_fn_0185
	,case_fn_0186
	,case_fn_0187
	,case_fn_0000
	,case_fn_0189
	,case_fn_0190
	,case_fn_0191
	,case_fn_0192
	,case_fn_0193
	,case_fn_0194
	,case_fn_0195
	,case_fn_0000
	,case_fn_0197
	,case_fn_0000
	,case_fn_0199
	,case_fn_0200
	,case_fn_0201
	,case_fn_0202
	,case_fn_0203
	,case_fn_0204
	,case_fn_0000
	,case_fn_0206
	,case_fn_0207
	,case_fn_0208
	,case_fn_0209
	,case_fn_0210
	,case_fn_0211
	,case_fn_0212
	,case_fn_0213
	,case_fn_0214
	,case_fn_0215
	,case_fn_0216
	,case_fn_0000
	,case_fn_0218
	,case_fn_0219
	,case_fn_0220
	,case_fn_0221
	,case_fn_0222
	,case_fn_0223
	,case_fn_0000
	,case_fn_0225
	,case_fn_0226
	,case_fn_0227
	,case_fn_0000
	,case_fn_0229
	,case_fn_0230
	,case_fn_0000
	,case_fn_0232
	,case_fn_0233
	,case_fn_0234
	,case_fn_0000
	,case_fn_0236
	,case_fn_0000
	,case_fn_0238
	,case_fn_0000
	,case_fn_0000
	,case_fn_0000
	,case_fn_0242
	,case_fn_0243
	,case_fn_0244
	,case_fn_0245
	,case_fn_0246
	,case_fn_0247
	,case_fn_0248
	,case_fn_0249
	,case_fn_0250
	,case_fn_0251
	,case_fn_0252
	,case_fn_0253
	,case_fn_0254
	,case_fn_0255
	,case_fn_0256
	,case_fn_0257
	,case_fn_0258
	,case_fn_0259
	,case_fn_0260
	,case_fn_0261
	,case_fn_0262
	,case_fn_0263
	,case_fn_0264
	,case_fn_0265
	,case_fn_0266
	,case_fn_0267
	,case_fn_0268
	,case_fn_0000
	,case_fn_0270
	,case_fn_0271
	,case_fn_0272
	,case_fn_0273
	,case_fn_0274
	,case_fn_0275
	,case_fn_0276
	,case_fn_0277
	,case_fn_0278
	,case_fn_0279
	,case_fn_0280
	,case_fn_0281
	,case_fn_0282
	,case_fn_0283
	,case_fn_0284
	,case_fn_0285
	,case_fn_0286
	,case_fn_0287
	,case_fn_0000
	,case_fn_0289
	,case_fn_0000
	,case_fn_0291
	,case_fn_0292
	,case_fn_0000
	,case_fn_0294
	,case_fn_0000
	,case_fn_0296
	,case_fn_0297
	,case_fn_0298
	,case_fn_0000
	,case_fn_0300
	,case_fn_0000
	,case_fn_0302
	,case_fn_0303
	,case_fn_0000
	,case_fn_0305
	,case_fn_0306
	,case_fn_0307
	,case_fn_0308
	,case_fn_0309
	,case_fn_0310
	,case_fn_0000
	,case_fn_0312
	,case_fn_0313
	,case_fn_0314
	,case_fn_0315
	,case_fn_0316
	,case_fn_0317
	,case_fn_0318
	,case_fn_0319
	,case_fn_0320
	,case_fn_0321
	,case_fn_0322
	,case_fn_0323
	,case_fn_0324
	,case_fn_0325
	,case_fn_0326
	,case_fn_0327
	,case_fn_0328
	,case_fn_0329
	,case_fn_0000
	,case_fn_0331
	,case_fn_0332
	,case_fn_0333
	,case_fn_0334
	,case_fn_0000
	,case_fn_0336
	,case_fn_0337
	,case_fn_0338
	,case_fn_0339
	,case_fn_0340
	,case_fn_0341
	,case_fn_0342
	,case_fn_0343
	,case_fn_0344
	,case_fn_0345
	,case_fn_0346
	,case_fn_0347
	,case_fn_0348
	,case_fn_0349
	,case_fn_0350
	,case_fn_0351
	,case_fn_0352
	,case_fn_0353
	,case_fn_0354
	,case_fn_0355
	,case_fn_0356
	,case_fn_0357
	,case_fn_0358
	,case_fn_0359
	,case_fn_0360
	,case_fn_0361
	,case_fn_0362
	,case_fn_0000
	,case_fn_0364
	,case_fn_0365
	,case_fn_0366
	,case_fn_0367
	,case_fn_0368
	,case_fn_0369
	,case_fn_0370
	,case_fn_0371
	,case_fn_0372
	,case_fn_0373
	,case_fn_0374
	,case_fn_0375
	,case_fn_0376
	,case_fn_0377
	,case_fn_0378
	,case_fn_0379
	,case_fn_0380
	,case_fn_0381
	,case_fn_0382
	,case_fn_0383
	,case_fn_0384
	,case_fn_0385
	,case_fn_0386
	,case_fn_0387
	,case_fn_0388
	,case_fn_0389
	,case_fn_0390
	,case_fn_0391
	,case_fn_0000
	,case_fn_0393
	,case_fn_0394
	,case_fn_0395
	,case_fn_0396
	,case_fn_0397
	,case_fn_0398
	,case_fn_0399
	,case_fn_0400
	,case_fn_0401
	,case_fn_0402
	,case_fn_0403
	,case_fn_0404
	,case_fn_0405
	,case_fn_0406
	,case_fn_0407
	,case_fn_0408
	,case_fn_0409
	,case_fn_0410
	,case_fn_0411
	,case_fn_0412
	,case_fn_0413
	,case_fn_0414
	,case_fn_0415
	,case_fn_0416
	,case_fn_0417
	,case_fn_0418
	,case_fn_0419
	,case_fn_0420
	,case_fn_0421
	,case_fn_0422
	,case_fn_0423
	,case_fn_0424
	,case_fn_0425
	,case_fn_0426
	,case_fn_0427
	,case_fn_0428
	,case_fn_0429
	,case_fn_0430
	,case_fn_0431
	,case_fn_0432
	,case_fn_0433
	,case_fn_0434
	,case_fn_0435
	,case_fn_0436
	,case_fn_0437
	,case_fn_0438
	,case_fn_0000
	,case_fn_0000
	,case_fn_0441
	,case_fn_0442
	,case_fn_0000
	,case_fn_0444
	,case_fn_0000
	,case_fn_0446
	,case_fn_0000
	,case_fn_0448
	,case_fn_0449
	,case_fn_0450
	,case_fn_0000
	,case_fn_0452
	,case_fn_0000
	,case_fn_0454
	,case_fn_0000
	,case_fn_0456
	,case_fn_0000
	,case_fn_0458
	,case_fn_0000
	,case_fn_0460
	,case_fn_0000
	,case_fn_0462
	,case_fn_0463
	,case_fn_0000
	,case_fn_0465
	,case_fn_0466
	,case_fn_0467
	,case_fn_0468
	,case_fn_0000
	,case_fn_0470
	,case_fn_0471
	,case_fn_0000
	,case_fn_0473
	,case_fn_0000
	,case_fn_0475
	,case_fn_0000
	,case_fn_0477
	,case_fn_0000
	,case_fn_0479
	,case_fn_0480
	,case_fn_0481
	,case_fn_0000
	,case_fn_0483
	,case_fn_0484
	,case_fn_0485
	,case_fn_0486
	,case_fn_0487
	,case_fn_0488
	,case_fn_0489
	,case_fn_0490
	,case_fn_0491
	,case_fn_0492
	,case_fn_0493
	,case_fn_0494
	,case_fn_0495
	,case_fn_0496
	,case_fn_0497
	,case_fn_0498
	,case_fn_0499
	,case_fn_0500
	,case_fn_0501
	,case_fn_0502
	,case_fn_0503
	,case_fn_0504
	,case_fn_0505
	,case_fn_0506
	,case_fn_0507
	,case_fn_0508
	,case_fn_0509
	,case_fn_0510
	,case_fn_0511
	,case_fn_0512
	,case_fn_0513
	,case_fn_0514
	,case_fn_0515
	,case_fn_0516
	,case_fn_0517
	,case_fn_0518
	,case_fn_0519
	};

static void
yy_vc_init(){ pcase_fn_array = case_fn_array;
yym_vc_max = 519;
 }
